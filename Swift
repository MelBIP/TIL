- 이름 짓기 규칙 -
Lower Camel Case : function, method, variable, constant
Upper Camel Case : type(class, struct, enum, extension…)
대소문자 구분


- 콘솔로그 -
printf
    단순 문자열 출력
dump
    인스턴스의 자세한 설명(description 프로퍼티)까지 출력
  
  
- 문자열 보간법 -
String Interpolation
프로그램 실행 중 문자열 내에 변수 또는 상수의 실질적인 값을 표현하기 위해 사용
  \ () 사이에
    let age: Int = 10
    ex) print(“안녕하세요! 저는 \ (age)살입니다”)
    
    
- 상수와 변수 -
상수
    상수 선언 키워드 : let
    선언 : let 이름: 타입 = 값
    값이 바뀌지 않음
변수
    변수 선언 키워드 : var
    선언 : var 이름: 타입 = 값
    값이 변함
    
    
- 기본 데이터 타입 -
Bool, Int, UInt, Float, Double, Character, String

- Bool
    
    var someBool: Bool = true
    
- Int
    
    var someInt: Int = -100
    
- UInt
    
    var someUInt: UInt = 100
    
- Float
    
    var someFloat: Float = 3.14
    
    someFloat = 3
    
- Double
    
    var someDouble: Double = 3.14
    
    someDouble = 3
    
- Character
    
    var someCharacter: Character = “🇰🇷”
    
    someCharacter = “😆”
    
    someCharacter = “가”
    
    someCharacter = “A”
    
- String
    
    var someString: String = “하하하 😆 ”
    
    someString = someString + “웃으면 복이와요”    
  
  
- Any, AnyObject, nil -
- Any
    - Swift의 모든 타입을 지칭하는 키워드(빈칸은 들어갈 수 X)
    - var someAny: Any = 100
    - someAny = “어떤 타입도 수용 가능”
    - someAny = 123.12
- AnyObject
    - 모든 클래스 타입을 지칭하는 프로토콜
    - class SomeClass {}
    - var someAnyObject: AnyObject = SomeClass()
- nil
    - 없음을 의미하는 키워드
    
    
- 컬렉션 타입 -
- Array
    - 순서가 있는 리스트 컬렉션
    - var integers: Array<Int> = Array<Int>()
    - append
    - contains(포함이 되어 있는가 아닌가)
    - remove(인덱스 없애달라)
    - removeLast(마지막 삭제)
    - removeAll(모두)
    - [Double] (Array<Double>축약형)
    - let 사용 → 불변 Array
- Dictionary
    - 키와 값의 쌍으로 이루어진 컬렉션
    - Dictionary<String, Any> = [String: Any] ()
    - [String: Any] (Dictionary<String, Any>축약형)
- Set
    - 순서가 없고, 멤버가 유일한 컬렉션
    - var integerSet: Set<Int> = Set<Int>()
    - 축약 문법 X
    - insert (요소 추가)
    - 중복값이 없다
    - contains(요소 있는지 없는지)
    - remove(삭제)
    - union(합집합)
    - sorted(정렬)
    - intersection(교집합)
    - subtracting(차집합)
    
    
- 함수 -
    - 함수 선언
    - func 함수이름(매개변수1이름: 매개변수1타입, 매개변수2이름: 매개변수2타입 …) → 반환타입 {
        
        함수 구현부
        
        return 반환값
        
        }
        
    - func sum(a: Int, b: Int) → Int {
    
          return a + b
    
    }
    
    - 반환값 없으면 void or 생략
    - 매개변수 없으면 괄호 안 비우기
- 함수 호출
    - sum(a: 3, b: 5)
    
    
- 함수 고급 -
1. 매개변수 기본값
    
    매개변수의 값이 들어오지 않아도 자동적으로 매개변수를 갖게 되는 것
    
    func 함수이름 (매개변수1이름: 매개변수1타입, 매개변수2이름: 매개변수2타입 = 매개변수 기본값 …) → 반환타입 {
    
    함수구현부
    
    return 반환값
    
    }
    
    기본값을 갖는 매개변수는 목록 중에 뒤쪽에 위치하는 것이 좋음
    
    func greeting(friend: String, me: String = “yagom”) {
    
    print(”Hello \(friend)! I’m \(me)”)
    
    }
    
    매개변수 기본값을 가지는 매개변수는 생략 가능
    
    greeting(friend: “hana”) // Hello hana! I’m yagom
    
    greeting(friend: “john”, me: “eric”) // Hello john! I’m eric
    
2. 전달인자 레이블
    
    전달인자 레이블은 함수를 호출할 때 매개 변수의 역할을 좀 더 명확하게 하거나 함수 사용자의 입장에서 표현하고자 할 때 사용
    
    func 함수이름(전달인자 레이블 매개변수1이름: 매개변수1타입, 전달인자 레이블 매개변수2이름: 매개변수2타입 …) → 반환타입 {
    
    함수 구현부
    
    return 
    
    }
    
    함수 내부에서 전달인자를 사용할 때에는 매개변수 이름을 사용
    
    func greeting(to friend: String, from me: String) {
    
    print(”Hello \(friend)! I’m \(me)”)
    
    }
    
    함수를 호출할 때에는 전달인자 레이블 사용해야 함
    
    greeting(to: “hana”, from: “yagom”) // Hello hana! I’m yagom
    
3. 가변 매개변수
    
    전달 받을 값의 개수를 알기 어려울 때 사용할 수 있음 
    
    가변 매개변수는 함수당 하나만 가질 수 있음
    
    func 함수이름(매개변수1이름: 매개변수1타입, 전달인자 레이블 매개변수2이름: 매개변수2타입…) → 반환타입 {
    
    함수구현부
    
    return
    
    }
    
    func sayHelloToFriends(me: String, friends: String…) → String {
    
    return “Hello \(friends)! I’m \(me)!”
    
    }
    
    print(sayHelloToFriends(me: “yagom”, friends: “hana”, “eric”, “wing”))
    

위에 설명한 함수의 다양한 모양은 모두 섞어서 사용 가능

1. 데이터 타입으로서의 함수
    
    스위프트는 함수형 프로그래밍 패러다임을 포함하는 다중 패러다임 언어
    
    스위프트의 함수는 일급객체이므로 변수, 상수 등에 저장이 가능하고 매개변수를 통해 전달할 수도 있음
    
2. 함수의 타입표현
    
    반환타입 생략 가능
    
    (매개변수1타입, 매개변수2타입 …) → 반환타입
     var someFunction: (String, String) → Void = greeting(to:from:)

someFunction(”eric”, “yagom”) // Hello eric! I’m yagom

someFunction = greeing(friend:me:)

someFunction(”eric”, “yagom”) // Hello eric! I’m yagom

var someFunction: (String, String) → Void = greeting(to:from:)

someFunction(”eric”, “yagom”) // Hello eric! I’m yagom

someFunction = greeing(friend:me:)

someFunction(”eric”, “yagom”) // Hello eric! I’m yagom


- 조건문 -
1. if - else
if condition {

statements

} else if condition {

statements

} else {

statements

}

if someInteger < 100 {

print(”100 미만”)

} else if someInteger > 100 {

print(”100 초과”)

} else {

print(”100”

} // 100

2. switch
switch value {

case pattern:

code

default:

code

}

switch someInteger {

case 0:

print(”zoro”)

case 1..<100:

print(”1~99”)

case 100:

print(”100”)

case 101…Int.max:

print(”over 100”)

default:

print(”unknown”)

} // 100

```swift
switch someInteger {

case 0:

print(”zoro”)

case 1..<100:

print(”1~99”)

case 100:

print(”100”)

case 101…Int.max:

print(”over 100”)

default:

print(”unknown”)

} // 100
```

- 반복문 -
1. for - in
```swift
switch “yagom” {

case “jake”:

pirnt(”jake”)

case “mina”:

print(”mina”)

case “yagom”:

print(”yagom!!”)

default:

print(”unknown”)

} // yagom!!
```

for (name, age) in people {

print(”\(name): \(age)”)

}

2. while
while condition {

code

}

while intgers.count > 1 {

intgers.removeLast()

}

repeat-while

repeat {

code

} while condition

repeat {

intgers.removeLast()

} while integers.count >0


// 
import UIKit

// 상수(let)와 변수(var)
let seonjin: String = "이선진 바보 멍충이"

var name: String = "SeonJin Lee"
let birthyear: Int = 2006

name = "이선진"

"\(birthyear)년에 태어난 \(name)은 바보 멍충이다"

// 배열(Array)과 딕셔너리(Dictionary)
// 대괄호를 이용해서 정의
// 대괄호 안에 어떤 타입 받을 지 명시
var languages: [String] = ["Swift", "Objective-C", "python"]

var capitals: [String: String] = [
    "한국": "서울",
    "일본": "도쿄",
    "중국": "베이징",
]

languages[0]  // swift
languages[1] = "Ruby"

capitals["한국"]  // 서울
capitals["프랑스"] = "파리"

// 빈 배열이나 빈 딕셔너리를 정의하고 싶다면 대괄호 쓺
var languages2: [String] = []
var capitals2: [String: String] = [:]

// 더 간결하게 선언하고 싶다면
var languages3 = [String]()
var capitals3 = [String: String]()
//타입 뒤에 괄호()를 쓰는 것은 생성자(Initializer)를 호출하는 것


// 조건문과 반복문
// if문
var age = 19
var student = ""

if age >= 8 && age < 14 {
    student = "초등학생"
} else if age < 17 {
    student = "중학생"
} else if age < 20 {
    student = "고등학생"
} else {
    student = "기타"
}

student  // 고등학생

// switch문
switch age {
case 8..<14:
    student = "초등학생"
case 14..<17:
    student = "중학생"
case 17..<20:
    student = "고등학생"
default:
    student = "기타"
}
// 8..<14 와 같이 범위 안에 age가 포함되었는지 여부 검사할 수 있음

// for문
for language in languages {
    print("저는 \(language) 언어를 다룰 수 있습니다.")
}

for i in 0..<100 {
    i
}

// i 대신 _사용하여 무시할 수도 이씅ㅁ
for _ in 0..<10 {
    print("Hello!")
}

// - 키워드는 어디서나 변수 이름 대신에 사용할 수 있음

// while문
var i = 0
while i < 100 {
    i += 1
}


// 옵셔널(Optional)
// 값이 있을 수도 없을 수도 있는 변수를 정의할 때 타입 어노테이션에 ?를 붙여야 함 이렇게 정의한 변수를 옵셔널이라고 함
// 옵셔널에 초깃값을 지정하지 않으면 기본값은 nil

var email: String?
print(email)  // nil

email = "s22005@gsm.hs.kr"
print(email)  // Optional("s22005@gsm.hs.kr")

// let optionalemail: String? = "s22005@gsm.hs.kr" 은 되지만
// let requiredEmail: String = optionalEmail은 컴파일 에러
// requiredEmail은 옵셔널이 아닌 String이기 때문에 항상 값을 가지고 있어야 함 반면에
// optionalEmail은 옵셔널로 선언된 변수이기 때문에 코드가 실행되기 전까지 값이 있는지 없는지 모름
// 따라서 Swift 컴파일러는 안전을 위해 requiredEmail에는 옵셔널로 선언된 변수를 대입할 수 없게 만듦

// 옵셔널 바인딩 (Optional Binding)
// 옵셔널의 값을 가져오고 싶은 경우에 사용하는 것이 옵셔널 바인딩
// 옵셔널 바인딩은 옵셔널에 값이 있는지 검사한 뒤, 존재한다면 그 값을 다른 변수에 대입시켜줌
// if let 또는 if var를 사용함
// 옵셔널의 값을 벗겨서 값이 있다면 if문 안으로 들어가고, 값이 nil이라면 그냥 통과하게 됨

