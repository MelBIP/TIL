- 이름 짓기 규칙 -
Lower Camel Case : function, method, variable, constant
Upper Camel Case : type(class, struct, enum, extension…)
대소문자 구분


- 콘솔로그 -
printf
    단순 문자열 출력
dump
    인스턴스의 자세한 설명(description 프로퍼티)까지 출력
  
  
- 문자열 보간법 -
String Interpolation
프로그램 실행 중 문자열 내에 변수 또는 상수의 실질적인 값을 표현하기 위해 사용
  \ () 사이에
    let age: Int = 10
    ex) print(“안녕하세요! 저는 \ (age)살입니다”)
    
    
- 상수와 변수 -
상수
    상수 선언 키워드 : let
    선언 : let 이름: 타입 = 값
    값이 바뀌지 않음
변수
    변수 선언 키워드 : var
    선언 : var 이름: 타입 = 값
    값이 변함
    
    
- 기본 데이터 타입 -
Bool, Int, UInt, Float, Double, Character, String

- Bool
    
    var someBool: Bool = true
    
- Int
    
    var someInt: Int = -100
    
- UInt
    
    var someUInt: UInt = 100
    
- Float
    
    var someFloat: Float = 3.14
    
    someFloat = 3
    
- Double
    
    var someDouble: Double = 3.14
    
    someDouble = 3
    
- Character
    
    var someCharacter: Character = “🇰🇷”
    
    someCharacter = “😆”
    
    someCharacter = “가”
    
    someCharacter = “A”
    
- String
    
    var someString: String = “하하하 😆 ”
    
    someString = someString + “웃으면 복이와요”    
  
  
- Any, AnyObject, nil -
- Any
    - Swift의 모든 타입을 지칭하는 키워드(빈칸은 들어갈 수 X)
    - var someAny: Any = 100
    - someAny = “어떤 타입도 수용 가능”
    - someAny = 123.12
- AnyObject
    - 모든 클래스 타입을 지칭하는 프로토콜
    - class SomeClass {}
    - var someAnyObject: AnyObject = SomeClass()
- nil
    - 없음을 의미하는 키워드
    
    
- 컬렉션 타입 -
- Array
    - 순서가 있는 리스트 컬렉션
    - var integers: Array<Int> = Array<Int>()
    - append
    - contains(포함이 되어 있는가 아닌가)
    - remove(인덱스 없애달라)
    - removeLast(마지막 삭제)
    - removeAll(모두)
    - [Double] (Array<Double>축약형)
    - let 사용 → 불변 Array
- Dictionary
    - 키와 값의 쌍으로 이루어진 컬렉션
    - Dictionary<String, Any> = [String: Any] ()
    - [String: Any] (Dictionary<String, Any>축약형)
- Set
    - 순서가 없고, 멤버가 유일한 컬렉션
    - var integerSet: Set<Int> = Set<Int>()
    - 축약 문법 X
    - insert (요소 추가)
    - 중복값이 없다
    - contains(요소 있는지 없는지)
    - remove(삭제)
    - union(합집합)
    - sorted(정렬)
    - intersection(교집합)
    - subtracting(차집합)
    
    
- 함수 -
    - 함수 선언
    - func 함수이름(매개변수1이름: 매개변수1타입, 매개변수2이름: 매개변수2타입 …) → 반환타입 {
        
        함수 구현부
        
        return 반환값
        
        }
        
    - func sum(a: Int, b: Int) → Int {
    
          return a + b
    
    }
    
    - 반환값 없으면 void or 생략
    - 매개변수 없으면 괄호 안 비우기
- 함수 호출
    - sum(a: 3, b: 5)
    
    
- 함수 고급 -
1. 매개변수 기본값
    
    매개변수의 값이 들어오지 않아도 자동적으로 매개변수를 갖게 되는 것
    
    func 함수이름 (매개변수1이름: 매개변수1타입, 매개변수2이름: 매개변수2타입 = 매개변수 기본값 …) → 반환타입 {
    
    함수구현부
    
    return 반환값
    
    }
    
    기본값을 갖는 매개변수는 목록 중에 뒤쪽에 위치하는 것이 좋음
    
    func greeting(friend: String, me: String = “yagom”) {
    
    print(”Hello \(friend)! I’m \(me)”)
    
    }
    
    매개변수 기본값을 가지는 매개변수는 생략 가능
    
    greeting(friend: “hana”) // Hello hana! I’m yagom
    
    greeting(friend: “john”, me: “eric”) // Hello john! I’m eric
    
2. 전달인자 레이블
    
    전달인자 레이블은 함수를 호출할 때 매개 변수의 역할을 좀 더 명확하게 하거나 함수 사용자의 입장에서 표현하고자 할 때 사용
    
    func 함수이름(전달인자 레이블 매개변수1이름: 매개변수1타입, 전달인자 레이블 매개변수2이름: 매개변수2타입 …) → 반환타입 {
    
    함수 구현부
    
    return 
    
    }
    
    함수 내부에서 전달인자를 사용할 때에는 매개변수 이름을 사용
    
    func greeting(to friend: String, from me: String) {
    
    print(”Hello \(friend)! I’m \(me)”)
    
    }
    
    함수를 호출할 때에는 전달인자 레이블 사용해야 함
    
    greeting(to: “hana”, from: “yagom”) // Hello hana! I’m yagom
    
3. 가변 매개변수
    
    전달 받을 값의 개수를 알기 어려울 때 사용할 수 있음 
    
    가변 매개변수는 함수당 하나만 가질 수 있음
    
    func 함수이름(매개변수1이름: 매개변수1타입, 전달인자 레이블 매개변수2이름: 매개변수2타입…) → 반환타입 {
    
    함수구현부
    
    return
    
    }
    
    func sayHelloToFriends(me: String, friends: String…) → String {
    
    return “Hello \(friends)! I’m \(me)!”
    
    }
    
    print(sayHelloToFriends(me: “yagom”, friends: “hana”, “eric”, “wing”))
    

위에 설명한 함수의 다양한 모양은 모두 섞어서 사용 가능

1. 데이터 타입으로서의 함수
    
    스위프트는 함수형 프로그래밍 패러다임을 포함하는 다중 패러다임 언어
    
    스위프트의 함수는 일급객체이므로 변수, 상수 등에 저장이 가능하고 매개변수를 통해 전달할 수도 있음
    
2. 함수의 타입표현
    
    반환타입 생략 가능
    
    (매개변수1타입, 매개변수2타입 …) → 반환타입
     var someFunction: (String, String) → Void = greeting(to:from:)

someFunction(”eric”, “yagom”) // Hello eric! I’m yagom

someFunction = greeing(friend:me:)

someFunction(”eric”, “yagom”) // Hello eric! I’m yagom

var someFunction: (String, String) → Void = greeting(to:from:)

someFunction(”eric”, “yagom”) // Hello eric! I’m yagom

someFunction = greeing(friend:me:)

someFunction(”eric”, “yagom”) // Hello eric! I’m yagom


- 조건문 -
1. if - else
if condition {

statements

} else if condition {

statements

} else {

statements

}

if someInteger < 100 {

print(”100 미만”)

} else if someInteger > 100 {

print(”100 초과”)

} else {

print(”100”

} // 100

2. switch
switch value {

case pattern:

code

default:

code

}

switch someInteger {

case 0:

print(”zoro”)

case 1..<100:

print(”1~99”)

case 100:

print(”100”)

case 101…Int.max:

print(”over 100”)

default:

print(”unknown”)

} // 100

```swift
switch someInteger {

case 0:

print(”zoro”)

case 1..<100:

print(”1~99”)

case 100:

print(”100”)

case 101…Int.max:

print(”over 100”)

default:

print(”unknown”)

} // 100
```

- 반복문 -
1. for - in
```swift
switch “yagom” {

case “jake”:

pirnt(”jake”)

case “mina”:

print(”mina”)

case “yagom”:

print(”yagom!!”)

default:

print(”unknown”)

} // yagom!!
```

for (name, age) in people {

print(”\(name): \(age)”)

}

2. while
while condition {

code

}

while intgers.count > 1 {

intgers.removeLast()

}

repeat-while

repeat {

code

} while condition

repeat {

intgers.removeLast()

} while integers.count >0
