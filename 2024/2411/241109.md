# 자료구조
## 해시 테이블
---
#### 해시함수
특정값을 원하는 범위의 자연수로 변경해주는 함수. 원하는 범위를 정하면, 해시함수를 활용하여 적절한 위치에 key값과 value값을 모두 저장함.

#### 해시함수의 조건
- 결정론적이어야 됨.
- 원하는 범위의 자연수 하나하나가 리턴될 확률이 최대한 비슷해야 됨.
- 빨리 계산을 할 수 있어야 됨.

#### 해시함수를 만드는 방법의 예
- 나누기 방법 : 테이블의 크기로 key를 나누고, 그 나머지를 활용
- 곱하기 방법 : 0 < a < 1인 아무 값을 key를 곱한 다음, 그 결과값에 배열의 크기를 곱함.

#### Data Chaining
해시 함수를 통해 생성된 값이 겹친다면 이를 어떻게 해결하고 저장할까?

첫번째 해결책으로 chaining이 있음. 각 겹치는 인덱스에 값을 링크드리스트로서 저장하는 방법. (각 key와 value를 노드로서 연결하며 저장함) 이렇게 하면 겹치는 부분이 있어도 정상적으로 값들이 저장됨.

탐색 또한 이를 활용하는데, 해시값이 겹친 것이 얼마나 있을지 모르므로, n개의 데이터를 해시테이블에 넣었을 때 최악의 경우는 O(n)만큼의 탐색시간이 필요함. (선형탐색)

삽입은 겹치는 값이 있으면 기존값을 덮어씌우고(아예 key값 자체가 같은 경우), 아닐 경우 해당 인덱스의 제일 마지막에 삽입되는 방식으로 작동함. 삽입도 결국은 탐색을 하다가 최종적으로 값을 바꿔주거나 추가하는 작업이 필요한 것인데, 이는 어차피 O(1)이므로 탐색과 마찬가지로 O(n)만큼의 시간복잡도가 필요함.

삭제의 경우도 탐색과 같은 과정은 거친 뒤 최종적으로 값을 지워주는 과정만 필요하므로 O(n)만큼의 시간복잡도가 필요함.

다만 지금까지 살펴본 케이스들은 모든 데이터들의 해시 함수 결과값이 겹친다는 매우 극단적인 경우임. 따라서 사실상 링크드 리스트의 길이의 평균(average_length)에 비례한다고 할 수 있음. 이는 'key - value 쌍 수(데이터 수) / 해시 테이블에 사용하는 배열 인덱스 수' 로 구할 수 있음. 이를 각각 n, m으로 표현하면 시간복잡도는 O(n/m)이라고 할 수 있는 것임. 그런데 이 때 '해시 테이블을 사용할 때는 만드는 배열의 길이를 데이터 수와 최대한 맞춘다.' 라는 규범을 적용하면 결국 시간복잡도는 O(1)이라고 할 수 있음.

다만 혼란을 줄이기 위해 정리하자면 '해시 테이블의 탐색,삽입,삭제는 평균적으로는 O(1), 최악의 경우에는 O(n)이 소요된다.' 라고 말할 수 있음.

#### Open Addressing
충돌을 해결하기 위한 또다른 방법으로는 Open Addressing이 있음. 해시함수 결과값이 겹치는 주소 대신 그냥 다른 비어있는 주소에 넣어주는 방법임.

비어있는 주소를 찾는 방법으로는 충돌이 일어난 주소부터 다음으로 1씩 인덱스를 더하며 비어있는지 확인하는 '선형탐사(Linear probing)', 제곱씩 인덱스를 더해주면서 확인하는 '제곱탐사(Quadratic Probing)' 가 있음.
(선형탐사 : +1 , +1, +1, ... / 제곱탐사 : +1, +4, +9, ...)

open addressing에서 탐색은 먼저 해시함수의 결과값에 따른 주소에서 탐사방법에 따라 이동하면서 일치하는 값을 찾아 존재여부를 확인함. 중간에 빈 인덱스를 만나면 그것은 그만큼은 저장이 안 되었다는 뜻이므로 탐색을 종료함.

삭제도 비슷한 과정을 거치지만 주의해야 함. open addressing을 통해 저장된 값이 여러개 있을때 그 사이의 중간값 하나가 그냥 사라지면, 탐색을 시도할 때 그만큼 저장이 안 되었다고 인식하여 탐색을 종료할 수 있기 때문임. 따라서 삭제된 위치에 "DELETED" 와 같은 표식을 남겨줌.