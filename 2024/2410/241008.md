# RxSwift 공부
## ControlProperty, ControlEvent
---
#### ControlProperty
ControlProperty는 Subject처럼 프로퍼티에 값을 주입할 수 있고 동시에 값의 변화도 관찰할 수 있는 타입임. 이는 `(UIElement).rx`를 통해 접근할 수 있음. ControlProperty를 사용하면 해당하는 프로퍼티의 변경사항을 데이터 시퀀스로 받아올 수 있음.

`UITextField+Rx.Swift`의 구현 예시
```swift
extension Reactive where Base: UITextField {
    ...
    public var text: ControlProperty<String?> {
        return value
    }
    ...
}
```
내부에 존재하는 text가 ControlProperty 타입임. 이는 `(UITextField).rx.text`로 접근할 수 있음. ControlProperty는 `bind(to:)` 메서드를 통해 subscribe를 수행할 수 있음. (`bind(to:)는 일종의 syntax suger로, 사용자에게 좀 더 직관적인 이해를 제공함. 내부적인 처리는 subscribe와 동일함.)

**Binder**
RxCocoa에는 내부 property를 Observer처럼 제공해 변경사항을 이에 바로 적용할 수 있도록 하는 기능도 존재함. 이를 Binder라고 함.

`UILabel+Rx.Swift`의 구현 내용
```swift
extension Reactive where Base: UILabel {
    ...
    public var text: Binder<String?> {
        return Binder(self.base) { label, text in
            label.text = text
        }
    }
```
내부에서 Binder라는 타입을 사용하고 있음. 데이터를 받아오면 이를 바로 UI Elements에 적용함.
```swift
public struct Binder<Value>: ObserverType {
    ...
}
```
`Binder` 타입의 정의를 보니 이 역시 ObserverType의 일종임을 확인할 수 있음.

ControlProperty와 Binder를 활용해 데이터 시퀀스의 반환 및 적용하는 예시
```swift
let results = query.rx.text
    .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
    }

results
    .map { "\($0.count)" }
    .bind(to: resultCount.rx.text)
    .disposed(by: disposeBag)
```
`query.rx.text`라는 ControlProperty를 통해 `fetchAutoCompleteItems`에 query를 날리고 이 반환값을 `resultCount.rx.text`라는 binder에 적용하고 있음.

#### ControlEvent
Cocoa에는 수많은 Event가 발생함. 그 이벤트는 ViewController가 Load되면 발생하는 ViewDidLoad에 대한 메세지가 될 수도 있고, User로 인해 발생하는 Tap Event가 될 수도 있음. ControlEvent는 이러한 Event들에 대한 시퀀서를 받아올 수 있는 기능임.

`UICollectionView+Rx`의 구현 예시
```swift
extension Reactive where Base: UICollectionView {

    /// Reactive wrapper for `delegate` message `collectionView:didSelectItemAtIndexPath:`.
    public var itemSelected: ControlEvent<IndexPath> {
        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didSelectItemAt:)))
            .map { a in
                return a[1] as! IndexPath
            }

        return ControlEvent(events: source)
    }
}
```
내부에서 itemSelected가 ControlEvent라는 타입을 사용하고 있음. 이는 `(UICollectionView)rx.itemSelected`로 접근할 수 있음. 이 역시 ControlProperty와 같이 bind하여 필요한 작업을 수행할 수 있음.

## Dirveet, Signal
---
#### Driver
Driver는 UILayer에서 반응형 작업을 좀 더 직관적으로 사용할 수 있도록 제공되는 개념임. Observable은 상황에 따라 BackgroundScheduler를 명확히 지정해줘야 하지만, Dirvar는 MainScheduler로 지정되어 있음. UI 관련적용에는 따로 Scheduler를 지정해줄 필요없이 Driver를 사용하여 실수를 방지하는 것이 좋음. (cf. 이름이 Driver인 이유는 목적 자체가 애플리케이션을 구동(Driver)하는 것에 있기 때문이라고 함.)

Driver의 특징 3가지
- 에러를 반환하지 않음
- MainScheduler에서 돌아감
- side effect를 share함 (`share(replay: 1, scope: .whileConnected)`)

cf. share?

한 번 생성한 시퀀스를 공유해 사용할 수 있도록 하는 Operator. share를 사용하면 발생한 이벤트가 버퍼에 저장되고, 새로운 subscription은 새로운 데이터 시퀀스를 생성하는 것이 아니라 버퍼에 저장된 이벤트를 전달받게 됨. replay는 버퍼의 사이즈를 의미하며, scope는`.forever`, `.whileConnected` 중 하나를 선택할 수 있음. `.forever`를 선택할 경우 버퍼가 subscription의 존재 여부에 관계없이 유지되며, `.whileConnected`를 선택할 경우 1개 이상의 subscription이 존재하는 동안에만 버퍼가 유지됨.

예시
```swift
let results = query.rx.text
    .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
    }

results
    .map { "\($0.count)" }
    .bind(to: resultCount.rx.text)
    .disposed(by: disposeBag)

results
    .bind(to: resultsTableView.rx.items(cellIdentifier: "Cell")) { (_, result, cell) in
        cell.textLabel?.text = "\(result)"
    }
    .disposed(by: disposeBag)
```
- `throttle` operator는 일정시간만큼 이벤트를 받지 않고 대기하도록 하는 operator임. 계속해서 데이터시퀀스가 전달될 것을 방지하는 역할을 함.
- 이렇게 받아온 query를 통해 서버에 데이터를 요청함.
- 이를 UI 요소에 적용함. (resultCount, resultsTableView)

이 코드의 문제점?
- 먼저 fetchAutoCompleteItems가 에러를 발생시키면 자연스럽게 데이터시퀀스가 종료될 것이고, UI는 새로운 쿼리에 대해 어떤 반응도 취하지 못할 것임.
- 또 fetchAutoCompleteItems가 background thread에서 동작해버리면, UI 요소에 접근하면서 충돌(에러)이 발생할 수 있음.
- 마지막으로 두 개의 bind를 수행하면서 같은 쿼리에 대해 두 번의 쿼리요청이 발생함.

문제점 해결
```swift
let results = query.rx.text
    .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
            .observeOn(MainScheduler.instance)  // results are returned on MainScheduler
            .catchErrorJustReturn([])           // in the worst case, errors are handled
    }
    .share(replay: 1)                           // HTTP requests are shared and results replayed
                                                // to all UI elements

results
    .map { "\($0.count)" }
    .bind(to: resultCount.rx.text)
    .disposed(by: disposeBag)

results
    .bind(to: resultsTableView.rx.items(cellIdentifier: "Cell")) { (_, result, cell) in
        cell.textLabel?.text = "\(result)"
    }
    .disposed(by: disposeBag)
```
- catchErrorJustReturn로 에러를 방지하고
- observeOn을 통해 MainScheduler에서 작업이 처리되도록 하고
- share를 적용해 데이터 시퀀스를 공유하도록 했음.

분명 문제를 해결했지만 규모가 큰 프로젝트에서 이들을 일일히 적용하는 것은 귀찮은 일임. 또 실수가 발생할 가능성도 있으니 이럴 때 사용하면 좋은 것이 Driver임.
```swift
let results = query.rx.text.asDriver()        // This converts a normal sequence into a `Driver` sequence.
    .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
            .asDriver(onErrorJustReturn: [])  // Builder just needs info about what to return in case of error.
    }

results
    .map { "\($0.count)" }
    .drive(resultCount.rx.text)               // If there is a `drive` method available instead of `bind(to:)`,
    .disposed(by: disposeBag)              // that means that the compiler has proven that all properties
                                              // are satisfied.
results
    .drive(resultsTableView.rx.items(cellIdentifier: "Cell")) { (_, result, cell) in
        cell.textLabel?.text = "\(result)"
    }
    .disposed(by: disposeBag)
```
- `asDriver`를 통해 ConrolProperty Trait을 Driver로 만들어주었음. (`onErrorJustReturn`을 통해 error 처리도 가능함.)
- `bind` 대신 `drive`를 통해 이를 적용했음. (`driver`는 Driver에 정의된 메서드로, 이를 활용하면 해당 데이터시퀀스가 절대 오류를 방출하지 않으며 메인 스레드에서 돌아가고, 데이터시퀀스를 share함을 명시적으로 파악할 수 있음.)

#### Signal
Driver와 유사하지만 버퍼를 가지지 않고 지난 데이터를 replay하지 않는다는 차이점이 있음. 
특징
- 에러가 발생하지 않음
- MainScheduler에서 돌아감
- side effet를 share함 (`share(scope: .whileConnected)`)
- 지난 데이터를 replay하지 않음

## Relay (PublishRelay, BehaviorRelay, ReplayRelay)
---
#### Relay
Relay는 RxSwift가 아니라 RxCocoa에 속하는 개념임. 

Subject는 .completed, .error의 이벤트가 발생하면 subscribe가 종료되는 반면, Relay는 .completed, .error를 발생하지 않고 Dispose되기 전까지 계속 작동하기 때문에 UI Event에서 사용하기 적절함. Subject를 Wrapping하는 형태로 구성되어 있음.

**PublishRelay**
```swift
/// PublishRelay is a wrapper for `PublishSubject`.
///
/// Unlike `PublishSubject` it can't terminate with error or completed.
public final class PublishRelay<Element>: ObservableType {
    private let subject: PublishSubject<Element>

    // Accepts `event` and emits it to subscribers
    public func accept(_ event: Element) {
        self.subject.onNext(event)
    }

    /// Initializes with internal empty subject.
    public init() {
        self.subject = PublishSubject()
    }

    /// Subscribes observer
    public func subscribe<Observer: ObserverType>(_ observer: Observer) -> Disposable where Observer.Element == Element {
        self.subject.subscribe(observer)
    }

    /// - returns: Canonical interface for push style sequence
    public func asObservable() -> Observable<Element> {
        self.subject.asObservable()
    }
}
```
- PublishSubject의 Wrapper 클래스.
- PublishSubject와는 다르게 completed 혹은 error와 함께 종료될 수 없음.
- accept 메서드를 통해 이벤트를 받고 subscriber에게 전송함.
- 내부에 PublishSubject가 있기 때문에 그 외 특징은 PublishSubject와 동일함. (초기값 없음)

**BehaviorRelay**
```swift
/// BehaviorRelay is a wrapper for `BehaviorSubject`.
///
/// Unlike `BehaviorSubject` it can't terminate with error or completed.
public final class BehaviorRelay<Element>: ObservableType {
    private let subject: BehaviorSubject<Element>

    /// Accepts `event` and emits it to subscribers
    public func accept(_ event: Element) {
        self.subject.onNext(event)
    }

    /// Current value of behavior subject
    public var value: Element {
        // this try! is ok because subject can't error out or be disposed
        return try! self.subject.value()
    }

    /// Initializes behavior relay with initial value.
    public init(value: Element) {
        self.subject = BehaviorSubject(value: value)
    }

    /// Subscribes observer
    public func subscribe<Observer: ObserverType>(_ observer: Observer) -> Disposable where Observer.Element == Element {
        self.subject.subscribe(observer)
    }

    /// - returns: Canonical interface for push style sequence
    public func asObservable() -> Observable<Element> {
        self.subject.asObservable()
    }
}
```
- BehaviorSubject의 Wrapper 클래스.
- BehaviorSubject와는 다르게 completed 혹은 error와 함께 종료될 수 없음.
- accpet 메서드를 통해 이벤트를 받고 subscriber에게 전송함.
- 내부에 BehaviorSubject가 있기 때문에 그 외 특징은 BehaviorSubject와 동일함. (초기값 필요, 값 보유)

**ReplayRelay**
```swift
/// ReplayRelay is a wrapper for `ReplaySubject`.
///
/// Unlike `ReplaySubject` it can't terminate with an error or complete.
public final class ReplayRelay<Element>: ObservableType {
    private let subject: ReplaySubject<Element>

    // Accepts `event` and emits it to subscribers
    public func accept(_ event: Element) {
        self.subject.onNext(event)
    }

    private init(subject: ReplaySubject<Element>) {
        self.subject = subject
    }

    /// Creates new instance of `ReplayRelay` that replays at most `bufferSize` last elements sent to it.
    ///
    /// - parameter bufferSize: Maximal number of elements to replay to observers after subscription.
    /// - returns: New instance of replay relay.
    public static func create(bufferSize: Int) -> ReplayRelay<Element> {
        ReplayRelay(subject: ReplaySubject.create(bufferSize: bufferSize))
    }

    /// Creates a new instance of `ReplayRelay` that buffers all the sent to it.
    /// To avoid filling up memory, developer needs to make sure that the use case will only ever store a 'reasonable'
    /// number of elements.
    public static func createUnbound() -> ReplayRelay<Element> {
        ReplayRelay(subject: ReplaySubject.createUnbounded())
    }

    /// Subscribes observer
    public func subscribe<Observer: ObserverType>(_ observer: Observer) -> Disposable where Observer.Element == Element {
        self.subject.subscribe(observer)
    }

    /// - returns: Canonical interface for push style sequence
    public func asObservable() -> Observable<Element> {
        self.subject.asObserver()
    }
}
```
- ReplaySubject의 Wrapper 클래스.
- ReplaySubject의 다르게 completed 혹은 error와 함께 종료될 수 없음.
- accpet 메서드를 통해 이벤트를 받고 subscriber에게 전송함.
- 내부에 ReplaySubject의 있기 때문에 그 외 특징은 ReplaySubject의 동일함. (버퍼 보유)

# OS 공부
## 프로세스
---
#### 프로세스 정의
- **프로세스** : 실행 중인 프로그램. 어떤 프로그램이 임의 시점에서 실행되고 있다면 그를 프로세스라고 함. 프로그램은 저장장치(하드디크스)에 존재함. 프로그램이 CPU가 이를 다룰 수 있도록 메인 메모리에 탑재되면 프로세스가 됨. 이들은 시스템 콜을 통해서 커널의 통제하에 시스템의 자원을 경제하는 주체들임.
- 시분할 시스템에서는 임의의 시점에 여러 프로세스가 동시에 수행하는 경우도 있음. 이를 **멀티태스킹**(혹은 멀티 프로세싱, 테스킹과 프로세싱은 같은 용어라고 봐도 무방)이라고 함.
- 프로세스는 그 주체에 따라 두 가지로 나뉨. 응용 프로그램이 실행되면 이는 **사용자 프로세스**라고 하고, 운영체제가 필요에 의해 생성하는 프로세스는 시스템 프로세스라고 함.

#### 문맥과 문맥교환
- **프로세스의 문맥(context)** : 시분할 환경에서 프로세스는 수행 중 계속해서 중단과 속개를 반복함. 프로세스는 이처럼 상태 변화가 있는 동적인 개체임. 이때 프로세스 중단시에는 보존되고 속개 시 다시 복구되어야하는 프로세스의 모든 실행정보를 문맥이라고 함.
- 문맥은 메인 메모리의 현재 상태를 의미하는 사용자 수준 문맥 / 커널이 관리하는 내용을 커널 수준 문맥으로 나눔.
- **사용자 수준 문맥** : (모든 각 프로세스가 가상 메모리 기법에 의하여 전체 메모리공간을 사용할 수 있다고 간주하자.) 메모리 제일 아래 영역인 text영역이 있음. 여기엔 컴파일된 기계어 프로그램 코드가 존재함. 그 위에는 광역변수가 들어가는 영역이 두 개 있음. 먼저 존재하는 data영역은 프로그램 개발시 광역 변수로 선언된 초기값이 지정된 변수가 저장됨. 그 위의 bass(Block Started by Symbol)에는 초기화되지 않은 광역변수가 들어감. 해당 공간에서는 변수명과 타입(크기)만 기억했다가 프로세스가 준비될 때 그 크기만큼의 메모리가 마련됨. 또 그 위에 존재하는 heap 영역은 프로그램에서 메모리를 동적으로 할당(malloc, free 등)할 때 사용되는 공간임. 맨 위에 존재하는 stack 영역에서는 프로그램 내의 함수가 호출될 때 call stack 자료가 push되고, 그 함수에서 리턴될 때 자료가 pop됨. 대표적으로 지역변수가 이렇게 다뤄짐. 참고로 heap은 아래에서 위로, stack은 위에서 아래로 운영됨. 이러한 모든 정보를 사용자 수준 문맥이라고 함.
- **커널 수준 문백** : 보통 CPU는 명령어를 읽어와서(Fatch), 이를 해독하고(Decode), 그에 맞는 회로적 기능을 수행하는 (Excute) 세 가지 과정을 반복적으로 수행함. PC는 다음으로 Fetch할 명령어의 주소를 담고 있음. 상태 레지스터임 PSR(Program Status Resister)는 Decode 시 그 결과로 변화되는 여러 상태가 기록되는 공간임. SP(Stack Pointer)는 사용자 수준 문맥에 해당되는 stack 공간에서 top에 해당되는 부분의 주소를 뜻함. 이 셋을 특수 레지스터라고 함. (cf. 이들은 프로세스가 중단될 때 PCB라는 특수한 자료구조에 저장됨.) 그 외에 다른 레지스터는 범용 레지스터인데, 특수 레지스터들과는 달리 사칙연산, 논리 연산에서 사용되는 계산 목적의 레지스터임. 커널 수준 문맥에는 이러한 특수 레지스터 내용과 범용 레지스터 내용, 그리고 프로세스의 현재 자원 사용정보, 커널의 프로세스 관리정보 모두가 포함된.
- **문맥 교환** : 프로세스들은 문백을 보존하면서 서로 번갈아 수행함. 이때 일어나는 작업이 문맥 교환함. 문백교환은 CPU를 다른 프로세스로 넘기는 작업임. 실행이 정지되는 프로세스의 문맥은 보존되고, 새로 실행되는 프로세스의 문맥이 활성화됨. 사용자 수준 문맥은 메모리에 그냥 남아이쏙, 커널 수준 문맥은 추후의 복구를 위해 PCB에 저장되었다가 속개시 원복됨. 이때 프로세스의 자원 사용정보나 커널의 프로세스 관리 정보는 원래 PCB에 저장되어 있어 그대로 두면 됨.
- 문맥 교환의 시점 : 문맥 교환의 시점은 타임슬라이스의 소진에 따른 스케쥴링으로 다른 프로세스에게 선정되거나 인터럽트로 CPU가 선점 당했을 때, (비자발적 문맥교환) / 프로세스 스스로 입출력을 요ㅊ어하거나 프로세스 스스로 다른 프로세스가 보낼 시그널에 대한 대기 요청으로 CPU를 반납할 때 (자발절 문맥교환)임.