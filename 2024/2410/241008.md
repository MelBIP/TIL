# RxSwift 공부
## ControlProperty, ControlEvent
---
#### ControlProperty
ControlProperty는 Subject처럼 프로퍼티에 값을 주입할 수 있고 동시에 값의 변화도 관찰할 수 있는 타입임. 이는 `(UIElement).rx`를 통해 접근할 수 있음. ControlProperty를 사용하면 해당하는 프로퍼티의 변경사항을 데이터 시퀀스로 받아올 수 있음.

`UITextField+Rx.Swift`의 구현 예시
```swift
extension Reactive where Base: UITextField {
    ...
    public var text: ControlProperty<String?> {
        return value
    }
    ...
}
```
내부에 존재하는 text가 ControlProperty 타입임. 이는 `(UITextField).rx.text`로 접근할 수 있음. ControlProperty는 `bind(to:)` 메서드를 통해 subscribe를 수행할 수 있음. (`bind(to:)는 일종의 syntax suger로, 사용자에게 좀 더 직관적인 이해를 제공함. 내부적인 처리는 subscribe와 동일함.)

**Binder**
RxCocoa에는 내부 property를 Observer처럼 제공해 변경사항을 이에 바로 적용할 수 있도록 하는 기능도 존재함. 이를 Binder라고 함.

`UILabel+Rx.Swift`의 구현 내용
```swift
extension Reactive where Base: UILabel {
    ...
    public var text: Binder<String?> {
        return Binder(self.base) { label, text in
            label.text = text
        }
    }
```
내부에서 Binder라는 타입을 사용하고 있음. 데이터를 받아오면 이를 바로 UI Elements에 적용함.
```swift
public struct Binder<Value>: ObserverType {
    ...
}
```
`Binder` 타입의 정의를 보니 이 역시 ObserverType의 일종임을 확인할 수 있음.

ControlProperty와 Binder를 활용해 데이터 시퀀스의 반환 및 적용하는 예시
```swift
let results = query.rx.text
    .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
    }

results
    .map { "\($0.count)" }
    .bind(to: resultCount.rx.text)
    .disposed(by: disposeBag)
```
`query.rx.text`라는 ControlProperty를 통해 `fetchAutoCompleteItems`에 query를 날리고 이 반환값을 `resultCount.rx.text`라는 binder에 적용하고 있음.

#### ControlEvent
Cocoa에는 수많은 Event가 발생함. 그 이벤트는 ViewController가 Load되면 발생하는 ViewDidLoad에 대한 메세지가 될 수도 있고, User로 인해 발생하는 Tap Event가 될 수도 있음. ControlEvent는 이러한 Event들에 대한 시퀀서를 받아올 수 있는 기능임.

`UICollectionView+Rx`의 구현 예시
```swift
extension Reactive where Base: UICollectionView {

    /// Reactive wrapper for `delegate` message `collectionView:didSelectItemAtIndexPath:`.
    public var itemSelected: ControlEvent<IndexPath> {
        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didSelectItemAt:)))
            .map { a in
                return a[1] as! IndexPath
            }

        return ControlEvent(events: source)
    }
}
```
내부에서 itemSelected가 ControlEvent라는 타입을 사용하고 있음. 이는 `(UICollectionView)rx.itemSelected`로 접근할 수 있음. 이 역시 ControlProperty와 같이 bind하여 필요한 작업을 수행할 수 있음.

## Dirveet, Signal
---
#### Driver
Driver는 UILayer에서 반응형 작업을 좀 더 직관적으로 사용할 수 있도록 제공되는 개념임. Observable은 상황에 따라 BackgroundScheduler를 명확히 지정해줘야 하지만, Dirvar는 MainScheduler로 지정되어 있음. UI 관련적용에는 따로 Scheduler를 지정해줄 필요없이 Driver를 사용하여 실수를 방지하는 것이 좋음. (cf. 이름이 Driver인 이유는 목적 자체가 애플리케이션을 구동(Driver)하는 것에 있기 때문이라고 함.)

Driver의 특징 3가지
- 에러를 반환하지 않음
- MainScheduler에서 돌아감
- side effect를 share함 (`share(replay: 1, scope: .whileConnected)`)

cf. share?

한 번 생성한 시퀀스를 공유해 사용할 수 있도록 하는 Operator. share를 사용하면 발생한 이벤트가 버퍼에 저장되고, 새로운 subscription은 새로운 데이터 시퀀스를 생성하는 것이 아니라 버퍼에 저장된 이벤트를 전달받게 됨. replay는 버퍼의 사이즈를 의미하며, scope는`.forever`, `.whileConnected` 중 하나를 선택할 수 있음. `.forever`를 선택할 경우 버퍼가 subscription의 존재 여부에 관계없이 유지되며, `.whileConnected`를 선택할 경우 1개 이상의 subscription이 존재하는 동안에만 버퍼가 유지됨.

예시
```swift
let results = query.rx.text
    .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
    }

results
    .map { "\($0.count)" }
    .bind(to: resultCount.rx.text)
    .disposed(by: disposeBag)

results
    .bind(to: resultsTableView.rx.items(cellIdentifier: "Cell")) { (_, result, cell) in
        cell.textLabel?.text = "\(result)"
    }
    .disposed(by: disposeBag)
```
- `throttle` operator는 일정시간만큼 이벤트를 받지 않고 대기하도록 하는 operator임. 계속해서 데이터시퀀스가 전달될 것을 방지하는 역할을 함.
- 이렇게 받아온 query를 통해 서버에 데이터를 요청함.
- 이를 UI 요소에 적용함. (resultCount, resultsTableView)

이 코드의 문제점?
- 먼저 fetchAutoCompleteItems가 에러를 발생시키면 자연스럽게 데이터시퀀스가 종료될 것이고, UI는 새로운 쿼리에 대해 어떤 반응도 취하지 못할 것임.
- 또 fetchAutoCompleteItems가 background thread에서 동작해버리면, UI 요소에 접근하면서 충돌(에러)이 발생할 수 있음.
- 마지막으로 두 개의 bind를 수행하면서 같은 쿼리에 대해 두 번의 쿼리요청이 발생함.

문제점 해결
```swift
let results = query.rx.text
    .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
            .observeOn(MainScheduler.instance)  // results are returned on MainScheduler
            .catchErrorJustReturn([])           // in the worst case, errors are handled
    }
    .share(replay: 1)                           // HTTP requests are shared and results replayed
                                                // to all UI elements

results
    .map { "\($0.count)" }
    .bind(to: resultCount.rx.text)
    .disposed(by: disposeBag)

results
    .bind(to: resultsTableView.rx.items(cellIdentifier: "Cell")) { (_, result, cell) in
        cell.textLabel?.text = "\(result)"
    }
    .disposed(by: disposeBag)
```
- catchErrorJustReturn로 에러를 방지하고
- observeOn을 통해 MainScheduler에서 작업이 처리되도록 하고
- share를 적용해 데이터 시퀀스를 공유하도록 했음.

분명 문제를 해결했지만 규모가 큰 프로젝트에서 이들을 일일히 적용하는 것은 귀찮은 일임. 또 실수가 발생할 가능성도 있으니 이럴 때 사용하면 좋은 것이 Driver임.
```swift
let results = query.rx.text.asDriver()        // This converts a normal sequence into a `Driver` sequence.
    .throttle(.milliseconds(300), scheduler: MainScheduler.instance)
    .flatMapLatest { query in
        fetchAutoCompleteItems(query)
            .asDriver(onErrorJustReturn: [])  // Builder just needs info about what to return in case of error.
    }

results
    .map { "\($0.count)" }
    .drive(resultCount.rx.text)               // If there is a `drive` method available instead of `bind(to:)`,
    .disposed(by: disposeBag)              // that means that the compiler has proven that all properties
                                              // are satisfied.
results
    .drive(resultsTableView.rx.items(cellIdentifier: "Cell")) { (_, result, cell) in
        cell.textLabel?.text = "\(result)"
    }
    .disposed(by: disposeBag)
```
- `asDriver`를 통해 ConrolProperty Trait을 Driver로 만들어주었음. (`onErrorJustReturn`을 통해 error 처리도 가능함.)
- `bind` 대신 `drive`를 통해 이를 적용했음. (`driver`는 Driver에 정의된 메서드로, 이를 활용하면 해당 데이터시퀀스가 절대 오류를 방출하지 않으며 메인 스레드에서 돌아가고, 데이터시퀀스를 share함을 명시적으로 파악할 수 있음.)

#### Signal
Driver와 유사하지만 버퍼를 가지지 않고 지난 데이터를 replay하지 않는다는 차이점이 있음. 
특징
- 에러가 발생하지 않음
- MainScheduler에서 돌아감
- side effet를 share함 (`share(scope: .whileConnected)`)
- 지난 데이터를 replay하지 않음