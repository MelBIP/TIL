# RxSwift 공부
## Subject
---
#### Subject
Subject는 Obersvable이나 Observer인 존재. 값을 수동으로 추가할 수 있고, 해당 값을 이를 구독중인 Subscriber에게 발행할 수 ㅆ음.

```swift
example(of: "PublishSubject") {

    // 1
    let subject = PublishSubject<String>()

    // 2
    subject.onNext("Is anyone listening?")

    // 3
    let subscriptionOne = subject
        .subscribe(onNext: { (string) in
            print(string)
        })

    // 4
    subject.on(.next("1"))        //Print: 1

    // 5
    subject.onNext("2")        //Print: 2
}
```
- `PublishSubject`라는 Subject 생성.
- 이때는 Observer가 없기 때문에 아무런 동작도 하지 않음.
- subscribe를 통해 observer를 생성해줌. (이때 이전에 발행한 "Is anyone listening?" 값은 받을 수 없음. `PublishSubject`는 현재 존재하는 observer에게만 이벤트를 방출하기 때문.)
- 1이 출력됨.
- 2가 출력됨. (cf. `òn(.next(_:))`와 `onNext(_:)`는 같은 것임.)
이처럼 Subject는 외부로부터 값을 받고 이를 그대로 방출할 수 있음.

#### Subject의 종류
Subject에는 4가지 종류가 존재함.
**PublishSubject**
- 초기값을 가지지 않고 새로운 값을 등록된 Subscriber에게 방출만하는 Subject임.
- 구독되었을 때부터 새로운 이벤트를 수신하고 싶을 경우 사용함.
- 각 Subscriber들은 구독 이후에 방출된 값들에 대해서만 수신이 가능함.
- 단, completed와 error(완전 종료 이벤트)는 이후 구독한 Subscriber에게도 전달됨.
- 시간이 민감한 데이터를 모델링할 때 유용함. 예를 들어 실시간 경매 앱이 존재한다고 했을 때 경매 시간이 끝난 이후에 들어온 유저에게 "경매 시간이 얼마 남지 않았습니다!"와 같은 메세지를 전달하는 것은 매우 무의미함. PublishSubject 시간이 지나 구독을 시작한 Subscriber에게는 이벤트를 전달하지 않으므로, 무의미한 이벤트 전달을 하지 않을 수 있음.

**BehaviorSubject**
- 하나의 초기값을 가진 상태로 시작하고 등록된 Subscriber에게 초기값 혹은 최신값을 방출하는 Subject임.
- 마지막 .next 이벤트를 새로 등록된 Subscriber에게 반복한다는 점만 제외하면 PublishSubject와 유사함.
- 각 Subscriber는 구독하기 전에 방출된 값들부터 수신함.
- completed와 error 이벤트(완전 종료 이벤트)가 발생한 이후에 새로 구독한 Subscriber가 있다면 해당 Subscriber에게도 정보가 전달됨.
- 뷰를 가장 최신의 데이터로 채울 때 사용하기 좋음. 예를 들어 유저 프로필 화면을 BehaviorSubject를 통해 바인드해놓으면, 특정 값을 새롭게 가져오는 도중에도 초기값 혹은 최신값으로 화면을 항상 채워놓을 수 있음.

**ReplaySubject**
- 버퍼를 두고 초기화를 진행하며, 버퍼 사이즈 만큼의 값들을 유지하면서 등록된 Subscriber에게 버퍼 내용 혹은 최신값을 방출하는 Subject임.
- 새로운 Subscriber가 생기면 버퍼에 등록된 이벤트들을 그 Subscriber에게 방출함.
- completed와 error 이벤트(완전 종료 이벤트)가 발생하면 새로  Subscriber는 해당 이벤트만 수신함.
- 주의할 점은 버퍼들이 모두 메모리에서 관리된다는 점. 따라서 이미자 Array같이 큰 사이즈의 데이터를 버퍼에 넣는 것은 지양해야 함.
- 검색창같은 최근 내역을 필요로 하는 데이터를 구현할 때 적절함. 최근에 저장된 값을 지속적으로 관리할 수 있음.

**AsyncSubject**
- Subject가 Complete되면 가장 마지막에 존재하는 이벤트를 새로운 Subscriber에게 전달하는 Subject.
- 만약 가장 마지막 이벤트가 에러로 종료된다면 이벤트의 전달없이 에러만 출력됨.

## Scheduler
---
#### Scheduler란
Scheduler는 프로세스가 작동하는 context를 추상화한 것. 즉, Cocoa의 GCD와 비슷한 개념이라고 생각하면 됨.

Scheduler 중 하나인 MainScheduler의 코드.
```swift
public final class MainScheduler : SerialDispatchQueueScheduler {

    private let mainQueue: DispatchQueue

    let numberEnqueued = AtomicInt(0)

    /// Initializes new instance of `MainScheduler`.
    public init() {
        self.mainQueue = DispatchQueue.main
        super.init(serialQueue: self.mainQueue)
    }
```
실제로 MainScheduler의 내부 프로퍼티인 mainQueue에 GCD의 일종인 DispatchQueue가 사용되고 있음을 알 수 있음.

#### Scheduler의 필요성
Observable의 Operator 체인에 멀티스레딩을 적용하고 싶을 경우, 특정 Scheduler를 사용하면 됨. Rx의 특정 Operator는 사용할 Scheduler를 파라미터로 전달 받기도 하는데, 이 Operator들은 자신이 처리할 연산의 일부 또는 전체를 전달된 Scheduler 내부에서 처리함.

Observable과 Operator의 체인은 모두 Scheduler를 기반으로 동작하고 일반적으로는 Subscribe 메서드가 호출되는 스레들르 사용해 Observer에게 데이터 시퀀스를 전달함. 하지만 `SubscribeOn` Operator를 사용하면 데이터시퀀스가 처음 전달되는 스레드를 바꿀 수 있음. `SubscribeOn` Operator는 다른 Scheduler를 지정해서 Observable이 해당 Sceduler를 통해 시퀀스를 전달하도록 함. 그리고 `ObserveOn` Operator는 Observer가 해당 시퀀스를 어떤 Scheduler에서 받아올지 결정함.

`SubscribeOn` Operator는 Operator 체인 중 언제 호출해도 문제되지 않음. 하지만 `ObserveOn` Operator는 Operator 체인 중 Observable이 사용할 스레드가 호출 제안 중 언제 할당되는지에 따라 그 이후의 Operator가 영향을 받음. (cf. 추가로 Dispose 과정 또한 `SubscribeOn`으로 지정된 Scheduler에서 수행됨.)

정리
- Scheduler를 사용하는 Operator는 앞서 언급한 `SubscribeOn`과 `ObserveOn`이 있음.
- `SubscribeOn`은 시퀀스를 어느 Scheduler에서 방출한 것인지를 결정함. 즉, 시퀀스의 시작점이 될 Scheduler를 결정할 수 있음.
- `ObserveOn`은 시퀀스를 어느 Scheduler에서 observe할 것인지를 결정함. 각각의 Operator 동작을 다른 스케줄러에서 처리하고 싶을 때 사용할 수 있음.

#### Scheduler의 종류
- **MainScheduler** : MainThread에서 수행해야 하는 작업을 추상화함. 일반적으로 UI 작업을 수행할 때 사용됨. MainSchedule.instance는 synchronous하게, MainSchedule.asyncInstance는 asynchronous하게 이벤트가 전달됨.
- **CurrentThreadScheduler** : 현재 thread에서 작업을 수행하도록 함. 이는 가장 기본적인(default) Scheduler임.
- **SerialDispatchQueueScheduler** : 특정 dispatchQueue에서 수행해야 하는 작업을 추상화함. Serial하게 작업을 처리함. (사실 MainScheduler도 SerialDispatchQueueScheduler의 일종임.)
- **ConcurrentDispatchQueueScheduler** : 특정 dispatchQueue에서 수행해야 하는 작업을 추상화함. Concurrent하게 작업을 처리함.
- **OperationQueueScheduler** : 특정 NSOperationQueue에서 수행해야 하는 작업을 추상화함. maxConcurrentOperationCount를 통해 작업양을 조절할 수 있음.

이 외에도 RxTest에 포함되는 TestScheduler나 직접 생성이 가능한 Custom Scheduler라는 개념도 존재하지만 활용도가 적음.

## Trait (Single, Completable, Maybe)
---
#### Trait
Trait은 Observable을 좀 더 안정성있고 의미있게 표현하기 위한 일종의 Syntax Sugar임. 그 종류는 Single, Completable, Maybe가 있음. Observable을 좀 더 좁은 범위로 제한하여 제공함으로써 코드를 더 명시적으로 표현하는 것임.

일반적으로 Trait은 아래와 같이 단순히 read-only Observable의 wrapper 형태로 구성되어 있음. 이렇게 Observable에 대한 접근을 제한해놓고 내부에 존재하는 Observable를 조정하여 일부 기능에 특화된 형태로 사용자에게 제공함.
```swift
struct Single<Element> {
    let source: Observable<Element>
    ...
}
```
**Single**
- .success(value) 혹은 .error 이벤트만을 방출함. .success(value)는 .next와 .completed가 합쳐져 있는 형태라고 생각하면 됨. 성공 또는 실패로 한 번에 확인할 수 있는 1회성 프로세스에 적절함. (ex. 데이터 다운로드, 디스크 데이터로딩)
- asSingle() 메서드를 통해 아무 Observable을 Single로 변환시켜서 확인할 수 있음.
- 생성과 사용은 Observable과 유사함.
```swift
func getRepo(_ repo: String) -> Single<[String: Any]> {
    return Single<[String: Any]>.create { single in
        let task = URLSession.shared.dataTask(with: URL(string: "https://api.github.com/repos/\(repo)")!) { data, _, error in
            if let error = error {
                single(.error(error))
                return
            }

            guard let data = data,
                  let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves),
                  let result = json as? [String: Any] else {
                single(.error(DataError.cantParseJSON))
                return
            }

            single(.success(result))
        }

        task.resume()

        return Disposables.create { task.cancel() }
    }
}
```
- subscribe로 이를 활용할 수 있음.
- SingleEvent는 .success 혹은 .error만을 제공함.
```swift
getRepo("ReactiveX/RxSwift")
    .subscribe { event in
        switch event {
            case .success(let json):
                print("JSON: ", json)
            case .error(let error):
                print("Error: ", error)
        }
    }
    .disposed(by: disposeBag)
```

**Completable**
- .completed 혹은 .error만을 방출하며 그 외에 어떠한 값도 방출하지 않음. 특정 처리가 제대로 완료되었는지만 확인하고 싶을 때 많이 사용함. (Ex. 파일 쓰기)
- observable이 값요소를 방출한 이상, 이를 Completable로 변활시킬 수는 없음.
- 이 역시 생성과 사용은 Observable과 유사함. 
```swift
func cacheLocally() -> Completable {
    return Completable.create { completable in
       // Store some data locally
       ...
       ...

       guard success else {
           completable(.error(CacheError.failedCaching))
           return Disposables.create {}
       }

       completable(.completed)
       return Disposables.create {}
    }
}
```
- subscribe로 이를 활용할 수 있음.
- CompletableEvent는 .completed 혹은 .error만을 제공함.
```swift
cacheLocally()
    .subscribe { completable in
        switch completable {
            case .completed:
                print("Completed with no error")
            case .error(let error):
                print("Completed with an error: \(error.localizedDescription)")
        }
    }
    .disposed(by: disposeBag)
```

**Maybe**
- Single과 Completable이 섞인 버전. .success(value), .completed, .error 모두 방출될 수 있음. 프로세스가 성공 실패여부와 더불어 특정 값을 뱉을 수 있을 때 사용함.
- asMaybe() 메서드를 통해 아무 Observable을 Maybe로 변환시켜서 확인할 수 있음.
- 이 또한 생성과 사용은 Observable과 유사함.
```swift
func generateString() -> Maybe<String> {
    return Maybe<String>.create { maybe in
        maybe(.success("RxSwift"))

        // OR

        maybe(.completed)

        // OR

        maybe(.error(error))

        return Disposables.create {}
    }
}
```
- subscribe로 이를 활용할 . 수있음.
```swift
generateString()
    .subscribe { maybe in
        switch maybe {
            case .success(let element):
                print("Completed with element \(element)")
            case .completed:
                print("Completed with no element")
            case .error(let error):
                print("Completed with an error \(error.localizedDescription)")
        }
    }
    .disposed(by: disposeBag)
```

# OS 공부
## 시스템 호출
---
#### 시스템 호출
- 응용 프로그램과 커널이 만나는 접점이 되어줌. 커널 API라 부르기도 하지만 시스템 호출 또는 시스템 콜이 정확함.
- 우리가 흔히 사용하는 printf나 open, read, wirte와 같은 함수들도 결국은 시스템 호출이 이루어져 커널의 함수가 동작하는 것임.
- 시스템 호출은 파라미터 전달과 CPU의 명령어 수행으로 이루어짐. 시스템 호출도 결국은 함수 호출과 개념상 동일하기 때문에 파라미터 전달이 필요함.
- Linux나 Solaris같은 OS의 경우 특정 시스템 호출에 필요한 파라미터를 메모리 상 특정 주소에 저장해놓고, 해당 메모리의 주소를 레지스터에 기록함. 그리고 해당 시스템 호출 함수가 수행되면 메모리의 해당 주소로 가서 해당 주소에 저장된 파라미터들을 읽는 방식으로 작동됨.
- 시스템 호출은 하드웨어 인터럽트와 다른 소프트웨어 인터럽트(트랩)으로 발생됨. 트랩 명령어인 instruction은 X86 계열의 장치에선 int, ARM계열 장치에선 swi가 있음.
- 이렇게 운영체제와 응용 프로그램간의 연결고리가 되는 시스템 호출이 파라미터 형식이나 번호 등에 있어서 차이가 있다면 치명적인 호환성 문제를 야기할 수 있음. 따라서 ISO/IEC, IEEE가 공동으로 재정한 POSIX(Portable Operating System Interface)를 표준으로 함. 프로세스의 제어, 파일 조작, 주변 장치 조작, 정보관리, 통신, 보호 6개의 유형으로 시스템 호출을 나눔.

#### 동기식 호출과 비동기식 호출
- **동기식 호출(Blocking call)** : 특정 시스템 콜을 할 때 그 결과값이 넘어오기를 기다린 후에 다음 라인을 수행하는 것임. 예를 들어 리드의 경우 하드디스크같은 하드웨어에서 데이터전송을 마치고, 커널이 전송을 마쳤다는 내용을 응용프로그램으로 전달하기까지 다음 라인으로 넘어가지 않고 기다린다는 것임. (CPU가 아무일을 안 하는 것은 아님. 시분할 시스템에 의해 다른 프로세스를 수행시키고 있을 것임.)
- **비동기식 호출(Non-blocking call)** : 시스템 콜이 이루어지는 커널에 콜만 요쳥해놓고 바로 다음 연산을 수행함. 그러다 해당 시스템 콜이 종료되면 그때 이벤트를 가져옴. 따라서 비동기식 호출의 경우에는 해당 이벤트를 처리할 함수를 파라미터로 넣도록 되어 있음. 이러한 함수를 콜백함수라고 하는데, 이벤트가 온다는 것은 곧 바로 이 콜백 함수가 불리는 것임. 콜백 함수는 시스템 콜로 전달된 데이터를 응용 프로그램이 일정 자료 구조로 저장하거나 처리하도록 함. 이러한 비동기식 호출은 디바이스 드라이버 등에서 필요한 기능을 잘 구현해놓은 경우에만 사용할 수 있기에 시스템 호출의 사용법을 잘 익히고 나서 사용해야 할 것임. (비동기식 호출은 시스템콜이 이루어지는 동안에도 프로세스 자체가 CPU를 사용할 수 있음.)

## 입출력 시스템
---
#### 입출력 시스템의 일반적 구성
- 입출력 장치는 '시스템 버스'와 연결되어야 하는데, 물리적인 입출력장치가 바로 시스템버스에 접속되어 있는 것은 아니고 '제어기'를 통해서 연결이 됨. 즉, 장치 제어기가 시스템 버스와 연결되어 있음.
- 응용 프로그램이 시스템 콜을 통해 커널의 파일 시스템 및 디바이스 드라이버에 연결되고, 커널의 디바이스 드라이버가 장치 제어기를 통해 입출력 장치 자체와 연결됨.
- 즉, 응용 프로그램이 시스템 콜을 호출하면 이 호출이 커널의 디바이스 드라이버에게 전달되고, 디바이스 드라이버 하드웨어인 장치 제어기와 명령 및 정보를 주고받으며 작업을 수행하고, 이러한 작업을 통해 입출력 장치가 통제되게 되는 것임.

#### 디바이스 드라이버와 장치제어기에 상호작용 (하드웨어 인터페이스)
- 디바이스 드라이버의 장치 제어기와 소통은 제어기 내부에 있는 특정 내부에 있는 특정 레지스터들의 값을 디바이스 드라이버가 읽거나 쓰는 방식으로 수행됨. 이러한 레지스터에는 명령 레지스터, 작업 레지스터, 자료 레지스터가 있음.
- **명령 레지스터**는 장치에게 쓰거나 읽는 동작을 명령하기 위한 명령 코드를 적재하는 곳임.
- **상태 레지스터**는 해당장치에 오류가 있는지, 작업이 진행 중인지, 작업을 끝내고 쉬고 있는지 등 장치의 상태를 체크하는 용도로 사용됨. busy/done 등의 플래그나 오류코드로 표현됨.
- **자료 레지스터**는 명령 레지스터를 통해 명령한 동작을 실행하는데 필요한 데이터를 읽고 쓰기 위한 버퍼같은 용도로 사용됨.

#### 커널과 디바이스 드라이버의 상호작용
- 디바이스 드라이버가 마치 커널과 하나인 것처럼 이야기했지만 사실 조금 다름.
- 디바이스 드라이버라는 것은 커널이 배포된 이후에도 업체들이 창의적으로 새로운 장치를 만들고 이를 제어할 수 있도록 구성한 것임. 즉, 커널 개발자는 커널의 소스코드를 변경하지 않고도 새로운 장치의 디바이스 드라이버를 플러그로 꽂고 뽑듯이 커널에 인스톨할 수 있도록 해야 함.
- 커널과 디바이스 드라이버 사이의 인터페이스에는 특정 드라이버에 필요한 함수들을 저장하는 테이블같은 자료구조가 존재함. 응용프로그램에서 해당 장치를 사용하고자 특정 시스템 콜을 하면 해당 신호가 트랩을 통해 커널 안으로 진입하고, 앞서 언급한 테이블에서 해당 드라이버내의 함수를 수행하도록 함. 이러한 과정을 통해 커널과 디바이스 드라이버간의 인터페이스가 동작하는 것임.
- 참고로 디바이스 드라이버는 커널 모드에서 커널과 함께 동작하기 때문에 커널 함수를 직접 호출하거나 커널 변수에 직접 접근할 수도 있음. 따라서 이를 활용한다면 커널의 기능을 효과적으로 활용하는 디바이스 드라이버를 만들 수도 있을 것임.

#### 레지스터 접근 방식
- 입출력장치의 레지스터를 접근하는 방식은 2가지가 있음.
- **격리형 입출력 (Isolated I/O, I/O mapped I/O)** : 메모리와는 별도의 공간을 가지는 방식임. 메모리 주소 지정을 위해 사용하는 주소 버스와 별도로 입출력 장치만을 위한 주소 라인을 따로 사용함. 따라서 주소값이 메모리 주소인지 입출력장치 주소인지 구분하는 제어 라인이 따로 필요한 하드웨어를 이룸. 이러한 하드웨어적 특성을 이용하기 위해 반드시 특수한 입출력 명령어를 사용해야 함. 입출력이 메모리 공간의 사용에 영향을 주지 않는다는 장점이 있지만, 별도의 명령어를 사용해야 하므로 프로그래밍의 일관성이나 이식성이 떨어진다는 단점이 있음.
- **메모리 사상형 입출력 (Memory-Mapped I/O)** : 메모리 주소 지정을 위한 주소 버스와 입출력 제어 라인을 공유함. 즉, 메모리에 할당된 주소 일부를 장치 제어기의 레지스터를 접근하는 주소로서 활용함. (이를 메모리 주소 공간에 제어기 레지스터를 '사상한다'라고 함.) 메모리 주소와 입출력 주소가 단일 공간에 존재하여 별도의 특수명령어 없이 LOAD나 STORE같은 메모리 접근을 위한 명령어를 사용할 수 있음. 따라서 명령어 개수가 줄어들어 프로그래밍이 용이하고 일관성과 이식이 뛰어나다는 장점이 있음. 하지만 입출력을 위하여 메모리의 일부를 사용하므로 메모리 공간에 영향을 준다는 단점이 있음.

#### 자료 이동 방식
- CPU가 장치제어기의 자료를 관리하는 방식임.
- **직접 입출력** : CPU가 장치제어가 내부 자료 레지스터의 자료 이동을 직접 관장하는 것임. 매번 입출력을 할 때마다 인터럽트를 걸어야하므로 부담이 될 수 있음. 따라서 입출력 발생의 시간 간격이 비교적 큰 문자 장치(키보드)에 주로 활용되고, 단위가 큰 블록 장치(하드 디스크)에서는 활용이 어려움. 블록의 단위를 512바이트라고 한다면 512번의 인터럽트가 일어나야 하는데 이는 사실상 불가능하기 때문.
- **DMA(Direct Memory Access)** : 이러한 한계를 극복하기 위해 개선된 방식임. 입출력 장치가 CPU의 도움없이 독자적으로 메모리에 접근하도록 하여 하나의 입출력 명령만으로 블록 단위의 입출력이 가능함. 하지만 CPU도 독립적으로 메모리에 접근하고 DMA도 독립적으로 메모리에 접근하면 서로 간에 충돌이 발생할 수 있음. 이러한 문제는 싸이클 스틸링 방식으로 해결함. (CPU와 DMA가 동시에 메모리 접근을 요구하면 DMA에게 우선권을 주고 CPU는 한싸이클을 쉼.) 어쨌든 이러한 DMA는 한 블록의 입출력 완료시에 한 번의 인터럽트만 발생하도록 하여 CPU에 부담을 줄여주고 블록 단위의 고속 입출력도 가능하게 함.

#### 폴링 방식과 인터럽트 방식
- 장치 제어기의 상태를 CPU가 알게 하는 방식은 먼저 지금까지 보았던 인터럽트 방식, 그리고 폴링방식 두 가지가 존재함.
- **폴링 방식** : CPU가 상태 레지스터를 반복적으로 체크하면서 목표한 상태로 바뀌었는지 체크하는 방식임. 디바이스 드라이버는 응용 프로세스로부터 요청이 들어오면, 장치 제어기의 명령 레지스터의 관련 명령어를 적재하고 이로 인해 장치가 가동됨. 그리고 상태 레지스터의 값을 체크하며 Busy 상태가 Done 상태로 바뀔 때까지 조건문을 반복적으로 수행함. 그러다 장치가 명령의 수행을 마쳐 Done 상태를 띄면 조건문을 만족하면 장치 제어기의 자료 레지스터의 내용을 가져오는 등의 요청받은 일을 수행함. 이러한 방법은 반복문을 무한히 돌게 되어 CPU를 낭비할 수 있음. (Busy Wating)
- **인터럽트 방식** : 폴링 방식에서의 CPU에 대한 부담을 줄이기 위해 고안된 방법임. CPU가 디바이스 드라이버 내의 코드를 수행함으로서 입출력 명령을 장치 제어기를 전송하고 CPU는 다른 프로세스를 수행하고 있다가 장치 제어기가 이를 알림방식으로 CPU에게 알려주는 것임. 하드웨어가 인터럽트 처리 체계를 갖추고 있다는 것을 전제로 함. 인터럽트가 들어오면 CPU는 현재 진행 중인 프로세스 또는 하위 ISR 수행을 중단하고 **(중단)** 프로그램 카운터(PC) 및 CPU 레지스터 값을 보존함. **(문맥보존)** 그리고 현재 인터럽트에 해당하는 마스크를 설정하여 자신보다 하위 인터럽트는 처리되지 않도록 함. **(마스크설정)** 마지막으로 현재 인터럽트에 해당하는 ISR로 점프하여 해당 과정을 실시함. **(ISR진입)** 인터럽트 처리가 끝나면 인터럽트 당항 프로세스 혹은 하위 ISR을 실행시키기 위해 레지스터 내용을 복구함. 특히 프로세스를 복구하는 경우 어떤 프로세스를 복구하여 진행시킬지 스케쥴링에 따라 결정함.

#### 다수준 인터럽트와 인터럽트 마스크
- 지금까지 자연스럽게 사용하던 '하위 인터럽트'라는 말에서 유추할 수 있듯이 인터럽트는 한 가지만 있는 것이 아님. 다양한 인터럽트 자치에서 다양한 인터럽트가 들어옴. 따라서 이들의 충돌을 방지하기 위해 우선순위(Interrupt priority level)가 존재함. 이에 따라 인터럽트에는 여러가지 수준이 존재할 것이므로 이를 **다수준 인터럽트**라고도 부름.
- 인터럽트 마스크는 순위를 비교하는 용도로 사용됨. 어떤 인터럽트가 발생하면 그보다 낮은 수준의 인터럽트는 통과될 수 없도록 함. 물론 그보다 높은 수준의 인터럽트는 마스크를 무시하고 통과할 수 있음. (이는 AND 연산자를 통해 처리됨. 새로 들어온 인터럽트 번호와 현재 수행중인 인터럽트 마스크 번호가 AND연산 처리됨. AND연산 후 값이 하나라도 남으면 지금 수행 중인 인터럽트를 계속 처리하고 그 후에 새로 들어온 인터럽트를 처리함.)
- cf. Fast Interrupt Handler : 특별히 빠른 처리 반응을 위해 다른 인터럽트 처리를 disable하고 짧은 시간 안에 처리를 마무리하는 것. time critical한 측면이 있는 clock interrupt같은 상황에서만 사용하는 것이 좋음. (되도록 다수준 인터럽트를 사용) 참고로 clock interrupt는 많은 작업을 동반하기 위해 이를 모두 해결하면 다음 작업을 처리하지 못할 수 있음. 따라서 순수 인터럽트 처리 부분은 top-half로, 나머지를 bottom-half로 구분함. 그리고 top-half는 fast interrupt 모드로, 나머지는 bottom-half에서 다수준 인터럽트로 처리하기도 함.

#### 입출력 시스템 정리
1. 부팅을 하면 커널에 필요한 함수들이 적재됨. 이에는 ISR이 실행될 수 있도록 돕는 Interrupt Descript Table와 디바이스 드라이버 등이 포함됨.
2. 응용 프로그램에서 시스템 호출 함수인 Read()를 부를 때는 입출력장치에서 읽어온 데이터를 저장하기 위한 공간이 필요함. 따라서 사용자 메모리 공간에 버퍼공간을 할당하여 해당 주소를 Read()의 파라미터로 활용함.
3. 함수를 실행하면 해당 신호가 트랩을 거쳐 커널의 디바이스 드라이버로 향하게 됨. 그리고 해당 디바이스 드라이버에 존재하는, 실질적으로 입출력장치 제어에 필요한 함수인 'sys_read 함수'까지 이름.
4. sys_read 함수는 장치제어기로부터 데이터를 받아야하므로 커널 공간 내에 새로운 버퍼 공간을 만듦. (사용자 메모리 공간과 커널 공간이 다르기 때문에 기존에 만들었던 버퍼공간을 활용할 수 없기 때문.)
5. 장치제어기의 명령레지스터에 Read() 명령어를 기록함. (이는 메모리 사상 입출력 방식을 사용하고 있기 때문에 가능한 일임. 아니라면 별도의 특수한 명령어를 통해 동작했을 것임.) 이때 커널 공간 내에 만들었던 버퍼공간의 주소도 함께 넘겨주는데, 이는 입출력 장치가 DMA를 통해 그 주소로 직접 접근할 수 있도록 시작주소를 알려주기 위함.
6. 그리고 장치제어기로부터 데이터를 받기 전까지 Sleep()을 통해 해당 프로세스는 잠들고 Sched()를 실행해 CPU가 다른 프로세스를 진행하고 있도록 함.
7. 장치제어기는 명령어를 받았으니 자료 레지스터에 응용 프로그램이 읽고자 했던 데이터를 받아옴. 데이터를 모두 받으면 커널 공간내에 할당했던 버퍼공간에 해당 데이터를 념겨줌. 이는 CPU의 간섭없이 DMA를 통해 전달됨.
8. 장치제어기가 CPU에게 인터럽트를 걸어 작업이 마무리됐음을 알림. 해당 인터럽트는 인터럽트 마스크 등이 동반되는 다수준 인터럽트 처리과정을 거쳐 IDT에서 해당 ISR함수 주소를 찾아 실행함. 그럼 다시 스케쥴링을 발생시키고 다시 우리가 사용하던 프로세스가 깨어남.
9. 그럼 sys_read함수의 sleep()다음 라인부터 코드가 진행됨. 커널 공간에 할당된 버퍼에 존재하는 데이터를 기존 사용자 메모리 데이터의 버퍼로 카피시켜주고, sys_read함수는 리턴됨.
10. 그럼 Read() 함수는 리턴되고, 처음 할당했던 사용자 메모리 버퍼에 원하는 데이터를 읽어오게 됨.

## 이중 모드
---
#### 이중모드와 모드비트
- '보호'라는 것은 기본적으로 커널의 모든 데이터가 응용 프로그램 등의 영향에 의해 손상되지 않도록 하는 것을 의미함. 하지만 커널의 구성요소를 다양함. 이 모든 것에 대해 하나하나 보호 방법을 강구하는 것을 매우 소모적임. 따라서 보다 근본적이고 연쇄적으로 작용할 수 있는 해결법을 찾는 것이 중요함.
- **이중모드** : 커널 모드와 사용자 모드 모두를 분리하는 방식임. 메인 메모리를 사용자 공간과 커널 공간으로 나누고 CPU가 사용자 공간 프로그램을 수행할 때는 사용자 모드로, 커널 공간 프로그램을 수행할 때는 커널 모드로 동작하도록 함. 즉, 어떤 응용 프로그램에서 커널이나 다른 프로그램의 오독장을 야기 시킬 수 있는 함수(코드)를 사용해야 할 때 커널 모드로 전환하여 이를 수행하는 것임. 이러한 이중 모드를 사용하는 이유는 잘못된 명렁어 사용, 운영체제나 타 프로그램의 주소 접근, 잘못된 입출력 등으로 하나의 응용프로그램의 오작동이 다른 프로그램의 오작동을 야기할 수 있기 때문임. 하지만 사용자 모드에서는 메모리 참조 영역이 제한되어 어느정도 보호가 이루어지지만 커널 모드에서는 제한이 없어지므로 코드 작성시 매우 신중해야 함.
- **이중모드의 실현** : 상태 레지스터에 모드비트를 두어 해당 비트가 0이면 커널 모드, 1이면 사용자 모드로 전환됨. CPU는 해당 비트를 참조하여 해당 비트가 0(커널 모드)인 경우에만 특권 명렁어를 수행할 수 있도록 함. 이 특권 명령어에는 입출력, 인터럽트, 모드 비트 변경 등에 관련된 명령어 등이 포함됨. 시스템 콜 후 트랩 과정을 거치면서 모드비트를 0으로 바꾸어 이러한 특권 명령어를 사용함. 리턴할 때는 다시 모드비트가 1로 바뀜.

#### 핵심 보호
- **불법(illegal) I/O 차단** : 모든 I/O 관련 명령어를 특권 명령어로 설정해놓음으로서 시스템 호출(트랩)을 통해서만 I/O가 가능하도록 함. 물론 I/O 관련 커널 영역인 ISR, 시스템 버퍼, 인터럽트 벡터, 디바이스 드라이버 등의 영역을 사용자 프로그램이 직접 접근할 수 없도록 하는 사전 작업이 동반되어야 함.
- **불법(illegal 메모리 접근 차단** : Base 레지스터와 Limit 레지스터로 프로그램 공간을 정의함. 특정 프로그램이 메모리를 접근하려 할 때 대상주소가 해당 범위를 벗어나는지 하드웨어적인 메모리 관리 유닛이 체크하고, 벗어나면 이에 트랩을 걸어 커널이 처리하도록 함. 리눅스 C프로그래밍시에 종종 발생하는 'Segmentation Fault' 오류는 주소 설정이 잘못되어 Base 레지스터 ~ Limit 레지스터의 공간을 벗어났을 때 발생하는 오류임.
- **무한루프 방지** : 시분할 방식에서는 '타임 슬라이스'를 사용함. 타임슬라이스는 타이머 인터럽트로 구현되는데 이는 특권 명렁어로 만들어진 것임. 그러면 응용 프로그램이 악의적으로 타이머 인터럽트를 변경할 수 없게 되고, 시분할 시스템이 제대로 돌아가 무한 루프에 빠져 CPU 작동이 멈추는 것을 방지할 수 있게 됨.

#### 캐시
- 레지스터, 캐시, 메인메모리, 디스크 순서로 용량은 커지지만 속도는 느려짐. 이 중 캐시는 CPU의 레지스터와 메인 메모리 사이의 접근 속도 또는 전송량 차이를 완화시키기 위해 고안되었음. CPU에서 메인 메모리에 접근 시 해당 자료를 속도가 빠른 캐시에 복사해놓고 다음 접근시 필요한 자료가 캐시에 존재하면 이를 활용함.
- 다만 캐시에 무조건 자료가 존재하지 않을 것이라는 것이 문제인데, 이는 알고리즘으로 개선이 가능함. 특정 알고리즘을 활용해 이 확률(Hit Ratio라고 부름)을 90% 이상까지 개선 가능함.
- 메모리 계층 구조 : 캐시의 개념을 확장하여 구성함. 메모리는 레지스터 - 캐시 - 메인메모리 - 하드디스크 - 광디스크 - 자기테이프의 계층으로 이루어져 있음. 이렇게 하면 전체 용량은 최하위 기억장치의 용량처럼, 접근 속도는 최상위 기억장치의 속도처럼 활용할 수 있을 것임. (물론 이론적인 이야기)

#### 부트스트래핑
- **부트스트래핑** : 훈히 부르는 '부팅'. 어원적으로는 장화 뒤쪽에 달린 고리를 의미함. 해당 고리는 남의 도움 없이 장화를 혼자 신을 수 있게 하는 도구인데, 이 개념이 확장되어 남의 도움없이 자기가 직접 일을 한다는 뜻이 되었음. 즉, 운영체제의 시동을 운영체제 일부 기능이 스스로 수행한다는 의미임.
- 처음 전원이 들어오면 메인 메모리 공간에는 아무것도 없음. 따라서 전원을 켰을 때 아주 작은 프로그램이라도 어딘가에 존재해야만 부팅 과정을 시작할 수 있음. 이 프로그램이 ROM에 20~30바이트 정도로 존재하는 '롬 로더'임. 이 롬 로더는 DMA를 이용해 하드디스크 섹터에 존재하는 마스터 부트 레코드로부터 부트스트랩 로더의 첫번째 블록을 메인 메모리에 적재하고, 그 후 첫번째 블록의 작용으로 나머지 블록이 모두 적재되면 롬 로더는 메모리 상위장소로 이동되고 이번엔 커널 프로그램을 읽어들여 하위 기억장소에 적재함. 커널 적재가 모두 마무리되면 약속된 장소로 점프하여 커널을 시작시킴.

#### 커널의 종류
- 커널은 구성상 특징으로 두 가지로 구분됨.
- **모노리틱 커널** : 커널이 하나의 통으로만 이루어져 있음. 프로세스 관리, 메모리 관리, 파일 시스템, 입출력 관리 및 네트워크 관리 등의 모든 기능이 커널에 포함되어 있음. 따라서 효율성은 매우 높지만 다른 플랫폼으로의 이식성이나 확장성에 한계가 있음. 이러한 한계를 극복하기 위해 환경에 관련된 부분은 계층적으로 분리하기도 함. 대표적인 예로는 리눅스가 있음. 리눅스는 모듈 개념을 사용해 확장성 문제를 해결했음. 이러한 모노리틱 커널은 앞서 언급했듯이 효율성이 좋아 시스템 호출 속도가 빠르다는 장점이 있지만 새로운 하드웨어 플랫폼에 대한 이식성이 떨어지고, 모두 하나의 통에 들어있어 한 부분에서 발생한 문제가 다른 시스템에 영향을 줄 수 있으며, 구성요소 간 의존성이 높은 만큼 디버깅이 어렵다는 단점이 있음.
- **마이크로 커널** : 프로세스간 통신, 메모리 관리, 클럭 인터럽트 처리와 CPU 스케쥴링 등의 핵심기능만 커널에 포함시키고 나머지는 서버 형태로 두어 사용자 모드의 프로세스를 수행하도록 한 형태. 응용 프로그램이 시스템 호출을 하면 통신을 통해 파일 시스템이나 디바이스 드라이버 수행 프로세스로 메세지를 보내는 방식임. (시스템 호출의 결과도 메세지로 전달됨.) 통신 프로토콜이나 다바이스 드라이버 등의 수행은 사용자 프로세스로 존재하고 파일 시스템의 일종이 서버 프로세스로 수행됨. 인터럽트도 메세지를 보내 처리됨. 이러한 마이크로 커널은 유연성이 좋고 한 부분에서 발견된 오류가 전체로 퍼지지 않는다는 장점이 있음. 커널이 소형화되어 있고 서버들 중 필요한 부분만 골라서 제품을 구성할 수 있기 때문에 소형 내장 시스템에 활용하기도 좋음. 하지만 메세지 전송이 빈번해지면 속도가 느려지는 등의 성능적 문제가 발생할 수 있다는 단점이 있음.