# OS
## 세그먼테이션
--
#### 세그먼테이션
- 페이징 기법의 핵심은 메모리 공간을 동일한 크기로 나누는 것임. (논리공간은 페이지, 물리공간은 프레임)
- 하지만 실제로 사용자(개발자)는 자신의 프로그램을 동일한 크기의 페이지 모음으로 인식하기보단 함수는 함수대로, 자료구조는 자료구조대로 각각 단위 별로 메모리 상에 존재하는 것으로 인식함. 이러한 것을 '세그먼트'라고 부름.
- 세그먼트를 그대로 물리 메모리 운영에 반영해주는 기법을 '세그멘테이션'이라고 함.
- 이러한 세그멘테이션은 주소 결속 방식이 페이징과 유사하지만 다름. 페이지 테이블 대신 세그먼트 테이블을 활용해 해당 테이블에 각 세그먼트의 시작주소와 크기정보를 수록함. 크기정보는 세그먼트가 페이지처럼 고정적인 크기가 아니라서 추가된 정보임.
- 세그먼트를 활용하면 세그먼트 간 공유가 가능해져 메모리를 효과적으로 사용할 수 있음. 같은 프로그램을 사용하고 내부 데이터가 다른 어떤 프로세스 둘이 있다면(워드 프로그램), 이 둘은 세그먼트 테이블 중 일부가 동일해 메모리 상에 하나의 세그먼트만 탑재해 사용할 수 있게 되는 것임.

#### 세그먼트의 생성
- 페이지는 일률적으로 일정단위로 자르는 것이라 단순하게 처리가 가능하지만, 세그먼트는 그럴 수 없음.
- 컴파일러가 세그먼트를 구분하는 역할을 하여 프로그램 소스를 분석하면서 세그먼트를 식별하고 생성해냄.
- 그렇게 생성되는 세그먼트는 결국 우리가 이미 배운 프로세스 사용자 문맥을 구성하는 것들과 유사할 것임. 즉, 코드, 전역변수, 메모리 할당을 위한 heap, 쓰레드를 위한 stack, 여기에 표준 C 라이브러리, 링크되는 라이브러리 등이 세그먼트로 저장되는 것임. (리눅스 같은 경우 ELF 포멧을 따라 로더블 파일로 저장됨.) 이렇게 세그먼트 개념이 반영되어 생성된 로더블 프로그램이 로딩되면 각 세그먼트에 대해 번호가 매겨지고, 이 번호는 마치 페이지 테이블에서의 페이지 번호처럼 세그먼트 번호의 역할을 함.
- 결과적으로 세그먼테이션 기법 하의 논리주소는 세그번트 번호 s와 세그먼트 내 오프셋 d로 이루어짐.

#### 세그먼테이션 주소결속
- cpu로부터 발생한 주소를 s와 d 두 영역으로 나눔. s는 세그먼트 번호이고, d는 세그먼트 내 오프셋 값임.
- 먼저 s값을 기반으로 세그먼트 테이블의 항목을 찾아감. 그 곳에는 해당 세그먼트의 '한계값'과 '기준값'이 수록되어 있음. 한계값은 세그먼트의 크기와 같고, 기준값은 물리메모리 상 세그먼트의 시작주소(베이스주소)임.
- 한계값이 필요한 이유는 세그먼트 크기가 가변적이기 때문임. 해당 한계값이 d값과 비교하여 d값이 더 클 경우 세그먼트의 영역을 벗어나는 것이라는 사실을 알 수 있음.

#### Paged Segmentation
- 세그먼테이션 기법을 사용하면 페이징을 통해 해결된 외부단편화 문제가 다시 발생할 수 있음. 세그먼트의 크기가 가변적이기 때문임.
- 그에 따라 세그먼트 내부에서 페이징 기법을 사용하는 기법이 고안되었음. 이것이 'Page Segmentation'임.
- 이렇게 되면 세그먼트 테이블과 페이지 테이블 간의 관계 설정이 필요해짐. 세그먼트 테이블 내 항목이 그 세그먼트를 위한 페이지 테이블의 시작주소를 알려주도록 함. 이는 다단계 페이징 기법과도 유사함.

#### Page Segmentation - MULTICS
- 멀틱스 시스템의 주소변환 구조
STBR(세그먼트 테이블 베이스 레지스터)에 세그먼트 테이블의 시작주소가 저장되어 있음. 이 시작주소에 논리주소 s값을 더해 세그먼트 테이블 상 항목을 찾아감. 그 다음 d값이 세그먼트 길이(한계값)을 초과하면 에러이므로 트랩을 발생시키고 아닐 경우 계속 진행시킴. 그리고 해당 영역의 값을 p와 d로 나눠서 그 중 p에 해당하는 페이지의 프레임 번호를 찾음. (물론 이를 위해선 페이지 테이블 시작주소를 알아야하는데, 이는 세그먼트 테이블에 기록되어 있음.)
- 최종적으로는 세그먼트 테이블이 알려주는 페이지 테이블의 시작주소에 p값을 더해 페이지 테이블의 항목을 찾아가고, 거기서 p에 해당하는 프레임 번호 f를 찾아 오프셋인 d를 더해 최종적인 물리주소를 얻어냄.

#### Page Segmentation - INTEL
- 인텔 CPU는 기본적으로 세그먼테이션 기법과 페이지드 세그먼테이션 기법을 지원함.
- 논리주소는 셀렉터와 오프셋의 쌍을 지니고 있음. CPU 내에는 6개의 세그먼트용 레지스터가 있어서 한 프로세스는 동시에 6개의 세그먼트를 가리킬 수 있음.
- 이들 세그먼트 레지스터 값과 셀렉터 값을 활용해 일종의 세그먼트 테이블인 '디스크립터 테이블' 상의 정보를 얻고, 또 거기에 오프셋 값을 반영해 32비트 리니어 어드레스를 생성함.
- 해당 리니어어 어드레스(선형 주소)는 다단계 페이징 기법과 유사한 방식으로 주소 변환을 실시함.
- 바깥 페이지 테이블이라 할 수 있는 '페이지 디렉토리'에서 안쪽 페이지 테이블이라 할 수 있는 '페이지 테이블'의 시작주소를 얻어 그로부터 물리메모리의 프레임 번호를 얻어냄. 그리고 거기에 오프셋을 접합해 최종적인 물리메모리 주소를 얻어내는 것임.

#### ARM 계열 CPU의 페이징
- 데스크탑과 서버 분야에서 주류를 형성한 인텔과 달리 ARM은 저전력 기능을 무기로 모바일 분야의 주류를 형성했음.
- ARM의 경우 두가지의 페이지 크기와 페이징 기법을 차용하여 그에 따른 각각의 페이징 기법을 제공함.
- 4KB와 16KB 크기의 페이지인 경우에는 페이지 개수가 많아짐에 따라 2단계 페이징을 실시함.
- 1MB와 16MB 페이지(이를 '섹션'이라 부름.)를 위해선 1단계 페이징을 실시함.
- 페이징 속도 개선을 위해선 '2단계 TLB 기법'을 사용함.
- 바깥레벨은 2개의 마이크로 TLB(각각 데이타용과 명령어용)를 이용하고, 안쪽레벨은 한개의 메인 TLB 이용함.
- 주소변환은 마이크로 TLB층에서 시작하여 미스 발생시 주 TLB를 검색함. 양쪽 TLB 모두에서 미스가 발생하면 페이지 테이블을 검색함.