## Socket.IO
---
# 소켓이란?

- 소켓 → 프로토콜, ip주소, 포트 넘버로 정의됨
- 떨어져있는 두 호스트를 연결해주는 도구로써 인터페이스 역할.
- 데이터를 주고 받을 수 있는 구조체로 소켓을 통해 데이터 통로가 만들어짐.
- 소켓의 역할에 따라 클라이언트 소켓, 서버소켓으로 구분됨.

프로토콜과 ip주소, 포트 넘버로 떨어져있는 두 바이스를 연결해주는 역할

# WebSocket이란?

**웹소켓은 데이터가 누락되지 않게 하는 tcp 기반의 양방향 통신을 제공하는 컴퓨터 프로토콜**

HTTP 통신은 단방향 방식이고 연결이 유지가 안 되기 때문에 매번 업데이트 유/무를 확인하기 위해서 서버에 요청을 불러와야 함. 그리고 요청을 할 때마다 전체 데이터를 불러오게 됨. 그렇기 때문에 서버에 많은 부하가 생기게 됨.

하지만 웹소켓은 양방향 통신을 지원하게 되어 있고 또 서버와의 연결이 유지된 상태에서 데이터가 오갈 수 있게 해주기 때문에 실시간 데이터 전송이 가능하게 됨. 이럴 때 웹소켓을 이용한다고 생각하면 됨.

**간단히 요약하자면 서버와 클라이언트가 연결되어 있는 상태를 만들어 주기 위해서 사용한다고 생각하면 됨.**

**이 웹소켓을 개발자들이 더욱 편리하게 개발하기 위해서 만들어진 것이 Node.js의 socket.io 모듈이라고 생각하면 됨.** 

Socket.IO의 특징으로는 이벤트 기반 + 서버 소켓과 클라이언트 소켓을 연결하여서 실시간으로 양방향 통신이 가능함.

## Socket.io

→ Socket.IO는 웹 소켓 연결을 통해 클라이언트와 서버간에 실시간 양방향 통신을 가능하게 하는 JavaScript 라이브러리.

# Socket.IO 주요 개념

### 💬 Socket.IO 기본 개념

1. `Socket` : 소켓은 클라이언트와 서버 간의 연결을 나타냄. 소켓을 사용하여 실시간으로 데이터를 보내고 받을 수 있음.
2. `Server` : 서버는 클라이언트와의 소켓 연결을 설정하고 관리함. 서버는 클라이언트로 이벤트를 방출하거나 클라이언트로부터 이벤트를 수신할 수 있음.
3. `Client` : 클라이언트는 서버와의 소켓 연결을 설정하고 관리함. 클라이언트는 서버와 동일하게 서버로 이벤트를 방출하거나 서버에서 이벤트를 수신할 수 있음.

### 💬 Socket.IO 트래픽 격리 구분

1. `Event` : 이벤트는 소켓 연결을 통해 클라이언트와 서버간에 전송된 메세지. 이벤트 이름은 서버와 클라이언트에서 동일하게 선언하여야 함. (JSON, 문자열, 이진 등 모든 형식의 데이터 포함 가능)
2. `Namespace` : 네임 스페이스는 클라이언트와 서버 간의 별도의 통신 채널. 단일 서버에서 여러 네임 스페이스를 작성할 수 있으며, 클라이언트는 특정 네임 스페이스에 연결하여 해당 네임 스페이스의 다른 클라이언트에게만 이벤트를 수신하거나 방출할 수 있음.
3. `Room` : 룸은 함께 결합된 소켓 그룹. 소켓은 여러 룸에 합류하거나 떠날 수 있음. 룸은 연결된 모든 고객에게 방송하는 대신 특정 클라이언트 그룹에 메시지를 보내는데 유용함.

### 💬 Socket.IO 이벤트 송수신 방식

1. `Public` : Public은 연결된 모든 클라이언트에게 메시지가 전송되는 경우. Socket.IO에서 io.emit 연결 모든 클라이언트에게 메시지를 브로트 캐스트한 방법으로, 채팅 메시지와 같은 일반 메시지를 연결된 모든 클라이언트에게 보내는데 유용함.
    
    ```swift
    // 서버 측
    io.on('connection', (socket) => {
      socket.on('chat message', (msg) => {
        io.emit('chat message', msg); 
        
    // 연결된 모든 클라이언트에게 메시지 통신(브로드 캐스트)
      });
    });
    
    // 클라이언트 측 
    socket.on('chat message', (msg) => {
      console.log(`Received message: ${msg}`);
    });
    ```
    
2. `Private` : Private은 특정 클라이언트에게 보낼 때. Socket.IO에서 socket.emit 특정 클라이언트에게 메시지를 보내는 방법으로, 알림 또는 알림과 같은 개임 메시지를 특정 클라이언트에게 보내는데 유용.
    
    ```swift
    // 서버 측
    io.on('connection', (socket) => {
      socket.on('send notification', (msg, recipientId) => {
        io.to(recipientId).emit('notification', msg); 
    
    // 지정된 수신자에게 메시지 보내기
      });
    });
    
    // 클라이언트 측 
    socket.on('notification', (msg) => {
      console.log(`Received notification: ${msg}`);
    });
    ```
    
3. `Broadcasting` : Broadcating은 발신자 제외 모든 클라이언트에게 메시지가 전송되는 경우. Socket.IO에서 socket.broadcast.emit 발신자를 제외한 모든 연결된 클라이언트에게 메시지를 브로드 캐스트하는 방법으로, 발신자를 제외한 모든 연결된 클라이언트에게 사용자 조인 또는 종료와 같은 알림을 보내는데 유용.
    
    ```swift
    // 서버 측 
    io.on('connection', (socket) => {
      socket.on('user join', (username) => {
        socket.broadcast.emit('new user', username); 
    
    // 발신자를 제외한 연결된 모든 클라이언트에게 메시지 통신(브로드 캐스트)
      });
    });
    
    // 클라이언트 측 
    socket.on('new user', (username) => {
      console.log(`New user joined: ${username}`);
    });
    ```
    

### 💬 Socket.IO 이벤트 송수신 개념

1. `Emit` : 클라이언트에서 서버로 또는 서버에서 클라이언트로 이벤트를 보내는데 사용. 이벤트 이름과 보낼 데이터라는 두 가지 이상의 인수가 필요함.
    
    ```swift
    //첫 번째 인수는 이벤트 이름, 두 번째 인수는 전송될 데이터
    socket.emit('chat message', 'Hello, world!');
    ```
    
2. `To` : 특정 소켓이나 방에 이벤트를 방출하는데 사용. 이벤트가 전송될 소켓 ID 또는 방 이름이라는 하나의 인수가 필요함. 
    
    ```swift
    // to 메소드는 이벤트를 보낼 소켓 ID를 지정하는 데 사용
    io.to('12345').emit('chat message', 'Hello, world!');
    ```
    
3. `On` : 클라이언트 또는 서버에서 이벤트에 대한 리스너를 등록하는데 사용. 이벤트 이름과 이벤트를 처리하기 위한 콜백 함수라는 두 가지 이상의 인수가 필요함.
    
    ```swift
    //첫 번째 인수는 이벤트 이름, 두 번째 인수는 이벤트가 수신 될 때 호출되는 콜백 함수(데이터)
    socket.on('chat message', (message) => {
      console.log(`Received message: ${message}`);
    });
    ```
    
4. `Of` : 자체 소켓 및 이벤트 세트로 새 네임 스페이스를 만드는데 사용. 네임 스페이스의 이름이라는 하나의 인수가 필요함.
    
    ```swift
    // of 메소드는 새로운 네임 스페이스를 만드는 데 사용
    const chatNamespace = io.of('/chat');
    ```
    

# Socket.IO 작동 방식
**→ Socket.IO는 클라이언트와 서버간에 WebSocket 연결을 설정하여 작동함.**

서버는 들어오는 연결을 확인하고 클라이언트가 방출하는 이벤트를 처리함. 클라이언트는 서버를 연결하고 이벤트를 확인하거나 이벤트를 확인할 수 있음. 클라이언특타 이벤트를 방출하면 서버는 이벤트를 수신하여 클라이언트로 응답을 다시 보내거나 동일한 네임 스페이스 또는 방에 있는 다른 클라이언트로 이벤트를 브로드 캐스트 할 수 있음.

# Socket.IO에서 setTimeout을 호출해야 하는 이유?

→ Socket.IO의 주요 기능 중 하나는 많은 수의 연결 및 이벤트를 동시에 처리할 수 있다는 것임. 그러나 제대로 관리하지 않으면 성능 문제가 발생할 수 있음.

**성능 문제를 피하는 한 가지 방법은 `SetTimeout`과 `Socket.IO`를 함께 작동하는 것임.**

setTimeout 지정된 시간이 지난 후에 기능을 실행할 수 있는 내장 JavaScript 기능으로 Socket.IO에서 setTimeout 이벤트를 받은 후 클라이언트에게 승인을 보내는 등 특정 기능의 실행을 지연시키면 서버에 너무 많은 이벤트가 동시에 과부화되는 것을 방지할 수 있음.

```swift
// 서버 측
socket.on('message', (data, callback) => {

// 처리 수행
  setTimeout(() => {
    callback('success');
  }, 1000); // 확인을 보내기 전에 1초간 기다리기
});

// 클라이언트 측 
socket.emit('message', data, (response) => {
  console.log(response); // 1초 후 '성공' 로그 기록
});
```

# WebSocket vs Socket.IO

애초에 둘은 다른 개념. 웹소켓은 양방향 소통을 위한 프로토콜. 프로토콜은 쉽게 말하면 다른 컴퓨터끼리 소통하기 위한 약속이라고 이해하면 됨.

반면에, socket.io는 양방향 통신을 하기 위해 웹소켓 기술을 활용하는 라이브러리. 어찌보면 자바스크립트와 jQuery의 관계와 비슷하다고 할 수 있음.

그렇기 때문에 socket.io가 같은 기능을 구현하더라도 약간 느리지만, 많은 편의성을 제공함. 또한 Java, C++, Python 등 여러 언어들의 라이브러리 또한 지원됨.

### WebSocket

- HTML5 웹 표준 기술
- 매우 빠르게 작동하며 통신할 때 아주 적은 데이터를 이용함.
- 이벤트를 단순히 듣고, 보내는 것만 가능

### Socket.IO

- 표준 기술이 아니며, 라이브러리임.
- 소켓 연결 실패 시 fallback을 통해 다른 방식으로 알아서 해당 클라이언트와 연결을 시도함.
- 방 개념을 이용해 일부 클라이언트에게만 데이터를 전송하는 브로드캐스팅이 가능함.