# iOS 공부
## URLSession Cahce Policy
---
**Network Caching**
- 네트워크 작업은 고비용의 작업. 따라서 매번 동일한 데이터를 받아올 때마다 요청과 응답을 수행하게 된다면 시간 및 리소스를 상당히 낭비하게 됨.
- 그래서 필요한 것이 Caching임. Caching을 사용하면 불필요한 작업을 최대한 줄여서 시스템의 성능을 향상시킬 수 있음.
- URL Loading System을 통해 이러한 Caching에 설정을 수행할 수 있음.
- Cache Store 및 Cache Policy를 변경할 수 있음.
- URL Loading System에서는 4가지 Cache Policy를 제공함.
  - useProtocolCachePolicy : protocol 특성에 따른 기본 캐시정책 (서버에서 전달한 Cache-Control Header를 그대로 따름)
  - reloadIgnoringLocalCacheData : local 캐시를 무시하고 항상 네트워크에 접속하도록 설정하는 정책
  - returnCacheDataDontLoad : 네트워크에 접속하지 않고 항상 local 캐시를 사용하도록 설정하도록 하는 정책
  - returnCacheDataElseLoad : local 캐시를 확인하고 캐시가 없는 경우에만 네트우크에 접속하도록 설정하는 정책
- Cache를 저장하는 기간이 너무 길면 이미 관련 데이터가 업데이트되었음에도 사용자는 예전 데이터를 보게 될 위험이 있음. 따라서 이를 적절히 관리하도록 하는 것이 중요.
- Cache 관련 설정은 Request 혹은 Session 단계에서 설정이 가능함.
- 이렇게 저장되는 Cache에는 단순한 Data 뿐 아니라 서버 응답과 관련된 메타 데이터도 함께 저장됨. 저장 타입은 CachedURLResponse.

**Request에서 설정하기**
```swift
var request = URLRequest(url: url)
request.cachePolicy = .returnCacheDataElseLoad
```
- request에 cachePolicy를 지정하기만 하면 됨.
- 다만 이와 같이 returnCacheDataElseLoad 정책을 사용할 경우 캐시의 저장기간이 가장 중요함. 앞서 언급했듯이 이미 관련 데이터가 업데이트되었음에도 사용자는 예전 데이터를 보게 될 위험이 있기 때문.
- Swift에서는 Cache를 삭제하는 다양한 메서드를 제공하지만, 제대로 동작하지 않는 경우가 더 많아 전체 캐시를 삭제하는 메서드를 제외하고는 사용하지 않는다고 함.
- 따라서 Cache를 삭제하는 다양한 메서드를 제공하지만, 제대로 동작하지 않는 경우가 더 많아 전체 캐시를 삭제하는 메서드를 제외아혹는 사용하지 않는다고 함.
- 따라서 Cache를 삭제하지 않고 Cache Plicy를 임시로 바꾸는 방법으로 문제를 해결함.
```swift
var lastDate: Data?
    ...
if lastDate.timeIntervalSinceNow < -5 {
    request.cachePolicy = .reloadIgnoringLocalCacheData
    lastDate = Date()
} else {
    request.cachePolicy = .returnCacheDataElseLoad
}
```
- 마지막으로 접근한 시간과 현재 시간을 비교해 캐시 정책을 임시로 바꿔 접근하도록 함.
```swift
session.configuration.urlCache?.removeAllCachedResponses()
```
- 전체 캐시를 삭제하는 방법은 위와 같음.

**Session에서 설정하기**
```swift
let config = URLSessionConfiguration.default

config.requestCachePolicy = .returnCacheDataElseLoad

let session = URLSession(configuration: config, delegate: self, delegateQueue: OperationQueue.main)
```
- config에서 requestCachePolicy를 설정할 수 있음.
- 다만 Request에서 Cache Policy를 설정했다면 그 설정이 더 우선적으로 적용됨.
  
**Delegate를 사용하여 캐시에 추가적인 처리하기**
- URLSessionDataDelegate에는 cache가 처리되기 전에 호출되는 Delegate method가 존재함.
```swift
func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping (CachedURLResponse?) -> Void) {
    completionHandler(proposedResponse)
}
```
- proposedResponse에는 현재 캐시에 저장되려는 데이터임.
- 이를 completionHandler에 전달하면 캐시에 저장이 수행됨.
```swift
func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping (CachedURLResponse?) -> Void) {
    guard let url = proposedResponse.response.url else {
        completionHandler(nil)
        return
    }

    if url.scheme == "https" {
        let response = CachedURLResponse(response: proposedResponse.response, data: proposedResponse.data, userInfo: proposedResponse.userInfo, storagePolicy: .allowedInMemoryOnly)
        completionHandler(response)
    } else {
        let response = CachedURLResponse(response: proposedResponse.response, data: proposedResponse.data, userInfo: proposedResponse.userInfo, storagePolicy: .notAllowed)
        completionHandler(response)
    }
}
```
- 이런 방식을 응용하면 위와 같은 처리가 가능함.
- url의 scheme이 https인 경우에만 메모리 캐싱을 허용하고 있음.

## PhotoKit
---
**requestAuthorization**
- info.plist에서 Privacy - Photo Library Usage Description 옵션을 입력
- 옵션에 입력된 String 값이 권한요청 Alert 창에 출력됨.
- 그리고 앱 내부에서는 PHPhotoLibrary의 authorizationStatus 메서드 및 requestAuthorization 메서드를 사용함.
- class func authoricationSatus(for: PHAccessLevel) : 현재 앱의 권한 상태를 반환.
- class func requestAuthorization(for : PHAccessLevel, handler: (PHAuthorizationStatus) -> Void) : Photo 앱에 접근하는 것에 대한 권한 요청.
- 권한 상태는 총 5가지가 존재함.
  - case notDetermined
  - case restricted
  - case denied
  - case authorized
  - case limited

**권한 요청하기 예시 코드**
```swift
private func getPermissionIfNecessary(completion: @escaping (Bool) -> (Void)) {
    switch PHPhotoLibrary.authorizationStatus() {
    case .notDetermined:
        PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in
            if status == .authorized {
                completion(true)
            }
        }
    case .authorized:
        completion(true)
    default:
        completion(false)
    }    
}
```
- 권한이 있을 경우 completionHandler에 Boolean값을 전달해 작업을 수행하도록 구성.

**PHAsset, PHAssertCollection, PHCollectionList**
- PhotoKit에서 Photo에 접근하여 데이터를 가져올 때는 PHAsset, PHAssetCollection, PHCollectionList 3가지 모델을 활용하게 됨.
- PHAsset은 이미지 및 비디오, 라이브포토를 나타내는 모델.
- PHAssetCollection은 앨범을 나타내는 모델임.
- PHCollectionList는 앨범을 그룹화한 모델.
- 각 모델들은 데이터를 가져올 수 있는 fetch 메서드를 보유함.
- 이를 통해 PHFetchResult(사진 앱으로부터 가져온 데이터의 결과를 나타내는 객체)를 받아올 수 있음.

**PHFetchOptions**
- PHFetchOptions는 Asset 혹은 Collection 객체를 가져올 때 이들에 대한 필터링 및 정렬을 정의할 수 있는 객체
- 주로 NSPredicate 타입인 predicate를 사용하여 필터링을 정의하고, NSSortDescriptor 타입인 sortDescriptors를 사용하여 정렬을 정의함.
- 각 데이터타입별로 사용할 수 있는 Key값이 있기 때문에 이를 활용하여 필터링 혹은 정렬을 수행할 수 있음.
```swift
let allPhotosOptions = PHFetchOptions()
allPhotosOptions.sortDescriptors = [NSSortDescriptor(key: "creationDate", ascending: false)]
```
- sortDescriptors 활용 예시

**PHFetchResult**
- PHFetchResult는 각 모델을 기반으로 데이터를 나타내는 객체.
- Generic 형식으로 작성되어 있기 때문에 PHAsset, PHAssetCollection, PHCollectionList의 값을 PHFetchResult에 담아 가져올 수 있음.
- 내부에는 PHAsset, PHAssetCollection, PHCollectionList 데이터가 모여 있음.
- contains(), count(), object(at:) 등의 메서드를 사용해 내부에 존재하는 데이터를 탐색할 수 있음.
- 내부 데이터를 하나씩 순회하면서 작업할 수 있는 enumerateObjects 메서드도 제공함.

**PHImageManager**
- PHAsset에는 UIKit에서 바로 활용할 수 있는 형태의 이미지를 직접적으로 가지고 있지 않기 때문에 이를 추출하는 과정이 필요함.
- 이럴 때 사용하는 것이 바로 PHImageManager임.
- PHImageManager는 Asset의 이미지 및 제공 데이터를 캐싱하는 특징이 있기 때문에 추후 같은 대상으로 이미지를 추출할 때 더 빠른 처리가 가능함.
- 일반적으로 공유 PHImageManager 인스턴스를 default() 타입 메서드로 호출하여 사용함.
- PHImageManager는 이미지뿐 아니라 비디오, 라이브포토에 대한 추출도 제공하긴 함.

**PHImageRequestOptions**
- Iamge Manager 객체가 요청한 Image에 대한 표현에 영향을 미치는 옵션 객체.
- 이미지 처리의 동기적 처리를 설정하는 isSynchronous, 이미지 퀄리티 및 우선순위를 설정하는 deliverMode 등 다양한 옵션을 제공함.
- isSynchoronous는 false가 기본값이기 때문에 비동기적으로 처리하고 싶다면 false 옵션을 주저야 함.

