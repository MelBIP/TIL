# UIKit 공부
## Diffable Datasource
---
- 기존의 DataSource와 UI는 각각 시간에 따라 변경되는 자신만의 버전(truth)을 가지고 있는데, 이것이 맞지 않으면 에러가 발생.
- reladData를 수행하기 전까지는 중앙화된 하나의 버전(truth)가 존재하지 않아 에러가 발생하기 쉬움.
- reloadData를 수행하더라도 애니메이션없이 화면을 갱신하게 되기 때문에 사용자 경험을 저하시킬 수 있음.

**개념**
- 그에 따라 Apple에서 도입한 것이 Differable DataSource. performBatchUpdates()같은 복잡한 메소드를 사용하지 않고, apply()라는 하나의 메소드로 관리하게 됨.
- **Snapshot** : UI의 버전(truth)를 저장하는 개념. 각 section과 item에 대한 unique identifier를 저장하고 이를 기반으로 업데이트를 수행함. (IndexPath를 기반으로 업데이트하던 기존의 방식과 다른 점) apply()를 수행하면 새로운 snapshot이 적용됨.

**사용방법**
**가장 먼저 UICollectionViewDiffableDataSource를 생성해야 함. (TableView도 과정은 유사)**
UICollectionViewDiffableDataSource의 정의
- 정의된 UICollectionViewDiffableDataSource를 보면 Generic Class임을 알 수 있음.
- 또한 Generic에 해당하는 SectionIdentifierType과 ItemIdentifierType 모두 Hashable을 준수하는 타입이어야 함.
- cf. SectionIdentifierType : Section을 구분할 타입, 일반적으로 custom enum 혹은 int가 들어감. (반드시 Hashable해야 함)
- cf. ItemIdentifierType : Item을 구분할 타입, 일반적으로 custom class가 들어감. (반드시 Hashable해야 함)
```swift
dataSource = UICollectionViewDiffableDataSource<Int, UUID>(collectionView: collectionView) {
    (collectionView: UICollectionView, indexPath: IndexPath, itemIdentifier: UUID) -> UICollectionViewCell? in
    // configure and return cell
}
```
- 생성자를 통해 DiffableDataSource를 만듦.
- collectionView 파라미터에는 dataSource가 사용될 collectionView를 넣어주면 됨.
- 다음 파라미터가 되는 cellProvider(클로저)에는 cell을 구성하는 코드를 작성함.
- 클로저 내부에서 collectionView와 indexPath, itemIdentifier 모두 제공하기 때문에 이를 활용해 cell을 구현하면 됨. (collectionView에서 indexPath를 통해 cell을 가져오고 itemIdentifier를 기반으로 cell을 구성)

이제 Snapshot을 생성해서 apply해주어야 함.

NSDiffableDataSourceSnapshot의 정의
- UICollectionViewDiffableDataSource와 마찬가지로 SectionIdentifierType과 ItemIdentifierType를 필요로 함.
- UICollectionViewDiffableDataSource에서 선언해준 타입과 일치시켜주어야 함.
```swift
// Create a snapshot.
var snapshot = NSDiffableDataSourceSnapshot<Int, UUID>()        

// Populate the snapshot.
snapshot.appendSections([0])
snapshot.appendItems([UUID(), UUID(), UUID()])

// Apply the snapshot.
dataSource.apply(snapshot, animatingDifferences: true)
```
- NSDiffableDataSourceSnapshot을 통해 Snapshot을 생성하고 이를 datasoure의 apply메소드에 전달해주는 방식으로 업데이트 진행
- 원하는 곳에 위와 같은 구조의 코드를 입력해 갱신될 수 있도록 처리하면 됨.
- animatingDifferences 옵션을 true로 하면 애니메이션과 함께 변경사항을 보여줌.

## Frame vs Bounds
---
- CGPoint : 위치를 표현하기 위한 구조체. x좌표와 y좌표의 값을 CGFloat 값으로 가짐.
- CGSize : 크기를 표현하기 위한 구조체. 너비와 높이 값을 CGFloat 값으로 가짐.
- CGRect : 사각형의 위치(origin)와 크기(size)를 포함하는 구조체. origin과 size를 각각 CGPoint와 CGSize로 가짐.

UIView는 기본적으로 frame과 bounds값을 모두 가지는데, 둘 다 CGRect임.
둘 모두 좌표와 크기를 가진다는 의미.
하지만 둘의 차이를 보면
- **Frame** : SuperView의 좌표 시스템에서의 위치와 크기
- **Bounds** : 자신만의 좌표 시스템에서의 위치와 크기

#### Frame
**frame.origin**
특정 frmae.origin은 SuperView의 frame.origin을 출발점으로 처리됨.
예를 들어 rootView 아래 있는 A View가 있고, 그 아래에는 B View가 있고, A View의 frame.origin이 (10, 10)이라고 가정을 해보자.
A View는 rootView로부터 (10, 10) 떨어진 상태가 됨.
이때 B View의 frame.oritin(20, 20)이라고 해보면 rootView 기준으로는 (30, 30)만큼 떨어진 상태가 됨.
즉 frame의 origin은 superView의 origin에서 얼마나 떨어졌느냐를 표현한 값.

**frame.size**
size는 superView를 기준으로 현 View가 차지하는 공간임.
이때 view가 차지하는 공간은 해당 View의 최소, 최대 좌표를 기준으로 측정됨.
따라서 만약 View가 회전되어 이것의 최소, 최대 좌표가 변한다면 그만큼 frame.size도 변하게 됨.

#### Bounds
**bounds.size**
bounds의 size는 그냥 우리가 직관적으로 바라보는 View의 size 그 자체임.
View가 회전을 해서 최소, 최대 좌표를 기준으로 보면 차지하는 크기가 늘어났어도 순수하게 View가 차지하는 공간만을 기준으로 하는 것임.

**bounds.origin**
자신의 원점의 위치를 자신을 기준으로 어디에 둘 지 표현한 값이라고 보면 됨.
이 값을 변경한다고 해서 frame.origin처럼 자신의 위치가 이동되는 것은 아님. 
고정된 원점이 그대로 있는데 그 위치가 곧 View의 bounds.origin 쪽으로 변경되어 취급한다고 보면 됨. 
따라서 SubView가 존재할 경우에는 이에 따라 위치가 옮겨진 것처럼 보임.
- view의 origin을 변경하면 **"자기 자신은 가만히 있고, SubView들이 반대 좌표로 이동하는 것"**
- 처럼 보이지만 실제로는?
- **"Sub View들이 반대 좌표로 가는 게 아니라, View가 Sub View를 바라보는 시점(viewport)이 달라진 것"**
- viewport가 움직이는 것에 대해 다시 의문이 생긴다면
- https://babbab2.tistory.com/45 참고하시길 (미래의 나여)

