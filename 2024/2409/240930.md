# UIKit 공부
## UITableView
---
#### UITablewView란?
iOS의 UITableView는 하나의 열에 세로로 스크롤되는 콘텐츠 행등을 표시함. 스크롤할 수 있는 만큼 UIScrollView를 상속받고 있음. 테이블의 각 행에는 앱 콘텐츠의 일부분이 포함됨. 예를 들어 연락처 앱은 각 연락처의 이름을 별도의 행에 표시함. 또 설정앱으 사용가능한 설정 그룹이 행으로 표시됨. 하나의 긴 행을 표시하도록 테이블을 구성하거나 관련 행을 섹션형태로 그룹화하여 콘텐츠를 더 쉽게 탐색할 수도 있음.

일반적으로 Navigatioin View Controller와 함께 사용하는 것이 일반적임. 이는 테이블의 다양한 계층의 탐색을 용이하도록 도와줌. UITableView는 각 행의 콘텐츠를 표시하는 cell로 구성됨. 표준 cell 구성은 텍스트와 이미지의 단순한 조합이지만 원할 경우 사용자 커스텀 cell을 만들 수도 있음. 또한 header, footer를 생성해 각 그룹에 대한 추가적인 정보를 제공할 수도 있음.

#### UITableView 생성하기
공식문서를 보면 TableView의 생성자는 2개가 존재함을 알 수 있음.

`init?(coder: NSCoder)` 생성자는 unarchiver(스토리보드 혹은 xib 파일)를 기반으로 생성할 때 필요한 생성자이니 `ìnit(frame: CGRect, style: UITableView.Style)` 생성자만 확인하면 됨. frame은 보통 AutoLayout을 통해 잡아줄거니까 .zero로 크기가 없도록 만들어도 상관없음. 

Style은
- plain : 가장 기본적인 스타일
- grouped : 각 섹션에 고유한 행들의 그룹이 있는 스타일
- insetGrouped : 각 섹션의 그룹이 둥근 모서리 형태로 처리된 스타일
이렇게 3가지가 존재함

예를 들면
```swift
var tableView = UITableView(frame: .zero, style: .insetGrouped)
```
이런식으로 적어주면 됨

#### UITableViewDelegate
UITableViewDelegate는 TableView의 여러 기능을 대신 수행하는 역할을 함. UITableViewDelegate가 관리하는 기능은
- Custom Header 및 Footer View를 만들고 관리함.
- Row, Header 및 Footer에 대한 사용자 정의 높이를 지정함.
- 더 나은 스크롤 지원을 위해 높이 추정치를 제공함.
- Row에 Indent를 부여함.
- Row 선택에 응답함.
- Swipe를 포함한 action에 응답함.
- table의 내용을 편집하는데 도움을 줌.

## DequeueReusableCell (withIdentifier: for: ) vs (withIdentifier: )
---
- **func dequeueReusableCell(withIdentifier: for: )** : reuse identifier에 의해 확인된 재사용 가능한 TableVie의 cell을 리턴하고 이를 Table에 추가함.
- **func dequeueReusableCell(withIdentifier: )** : identifier에 의해 확인된 재사용 가능한 TableView의 cell을 배치하고 리턴함.

dequeueReusableell(withIdentifier: for:)을 통해 받아온 cell은 현재 TableView의 size 정보를 바로 가지고 있는 반면 dequeueReusableVell(withIdentifier: )의 통해 받아온 cell은 size 정보를 가지고 있지 않음.

- **func dequeueReusableCell(withIdentifier: for: )** 
  - **IndexPath** : 필요함
  - **리턴값 옵셔널** : 옵셔널 아님
  - **가져온 Cell size** : 해당 tableView에 맞춰짐
- **func dequeueReusableCell(withIdentifier: )**
  - **IndexPath** : 필요없음
  - **리턴값 옵셔널** : 옵셔널임 
  - **가져온 Cell size** : default (320.0, 44.0)

# OS 공부
## 뮤텍스와 세마포어의 차이
---
#### 뮤텍스
- 화장실이 하나 밖에 없는 식당
- 화장실에 가기 위해 카운터에서 열쇠를 가지고 가 그 열쇠를 이용해 화장실을 이용함.
- A가 화장실을 이용 중일 때는 B는 그 열쇠를 카운터에서 기다리게 됨.
- A가 화장실을 다 이용하고 열쇠를 반납하면 B는 그 열쇠를 받아 화장실에 가게 됨.
- **화장실을 이용하는 사람** : 프로세스 또는 스레드
- **화장실** : 공유자원
- Lock을 사용하여 오직 하나의 스레드만 임계 영역에 들어갈 수 있도록 하고 오직 Lock을 건 스레드만이 임계 영역에서 나갈 때 뮤텍스를 unlock 할 수 있음.
#### 세마포어
- 화장실이 여러 칸인 식당
- 화장실에 빈칸이 있다면 화장실에 들어가고, 빈칸의 개수가 0이 되면 1이 될 때까지 기다려야 함.
- **화장실을 이용하는 사람** : 프로세스 또는 스레드
- **화장실** : 공유자원
- 카운트를 가지고 있어 wait를 호출하면 세마포어의 카운트가 줄어들고 signal을 호출하면 카운트가 증가되어 카운트가 0이 되거나 더 작아질 경우 Lock이 실행됨.
- 그렇기 때문에 뮤텍스와는 다르게 Lock을 걸지 않은 스레드도 signal을 통해 Lock을 해제할 수 있음.

## 채널, 버퍼, 인터럽트
---
#### 운영체제의 필요성과 목적
- 메모리나 CPU와 같은 자원은 한정되어 있지만, 사용자는 충분히 무한할 수 있음. -> 이에 따라 이러한 사용자들의 자원 사용을 조율하기 위한 '운영자의 정책'이 필요함.
- 다양한 사용자를 받아들여 최적의 사용율을 보이는 '효율성'과 각각 사용자로서 하여금 불편함이 없을 만큼의 '편의성'을 둘 다 추구해야 함.
- 하지만 이 둘은 결국 상반된 개념임. 한 용자의 편의성을 위해 자원을 한 사용자에게만 주면 결국 자원을 효율적으로 사용하지 못하는 것이고, 모두에게 자원을 똑같이 분배하면 사용자가 많아질수록 사용에 불편을 겪을 수 있기 때문.
- 따라서 이 두 양극의 최적점을 찾는 것이 중요함.
- 정리하면 운영체제는 사용자 관점의 **편의성**, 자원 할당자로서 자원 활용의 **효율성** 마지막으로 다양한 입출력 장치의 운영 및 제어의 **일관성**을 추구해야 함. (운영체제의 목적)

#### 초기 시스템
- 기계어 프로그램을 주로 카드 천공기로 펀치카드에 기록하여 활요했음. 펀치 카드 박스에 프로그램을 담고, 규모가 커지면 마그네틱 테이프를 활용하기도 했음.
- 주로 10진수/8진수의 기계어이고 상대주소가 아닌 절대주소를 사용했음.
- 프로그래머가 콘솔이나 스위치를 이용하여 모든 작업을 수행했음. (테이프나 카드덱의 내용을 적재하고 콘솔을 이용해 프로그램을 수행/디버깅 했음. 라이브러리도 마찬가지로 카드덱 형태였음.)
- 남는 시간이 발생하고 준비 시간도 과도하여 비효율적이었음.
- 한 자원을 독점하니 편의성은 높았지만 효율성은 매우 낮았음. HW가 비싼 시기였기에 효율정을 증대시키는데 많은 노력을 기울였음.

#### 초기 일괄처리 시스템
- 운영자(오퍼레이터, 사람)을 고용하여 사용자들이 요구하는 비슷한 작업을 묶어 배치(batch)로 처리했음. (= 일종의 그룹으로 처리했음.)
- 위성컴퓨터는 배치를 받아 오프라인으로 자기 테이프에 이를 수록했고, 이를 주컴퓨터가 수행하게 한 후, 이 결과를 오프라인으로 위성컴퓨터에서 프린트로 출력했음. 그리고 운영자는 또 른 배치를 다시 위성컴퓨터에 수록, 주컴퓨터가 수행하도록 함. 이를 반복함.
- 쉽게 말해 주컴퓨터는 자기테이프의 작업만 처리하고, 위성커뮤터는 카드뭉치(배치)를 자기테이프로 만들고 결과를 프린트하는 작업만 처리한다는 것임.
- 배치라는 일괄처리 작업을 취급하는 것은 사람이었기 때문에 실수나 불공정함이 존재할 수 있다는 것이 단점이었음.
- 이에 따라 오퍼레이터를 대체하기 위해 채널과 버퍼 그리고 인터럽트라는 개념이 등장하였음.

#### 채널과 버퍼, 인터럽트
- 입추력 장치가 주 컴퓨터의 직접적으로 인터페이스가 되면 오퍼레이터의 작업을 없앨 수 있음.
- 그러면 주컴퓨터의 CPU가 과부화 될 수 있음.
- 채널과 버퍼, 인터럽트의 목적은 입출력장치의 작업과 주컴퓨터의 수행작업이 서로의 간섭없이 각자의 작업을 할 수 있도록 하여 CPU의 과부화를 막는데에 있음.
- 채널 : CPU의 간섭없이 독립적으로 메모리 특정 부분에 직접 자료를 전송하도록 해주는 회로(명령어, 레지스터 및 입출력 제어장치로 구성). CPU와 메모리를 공유하여 CPU로부터 명령을 받음. 이러한 작업을 CPU와는 독립적으로 입출력 처리함으로서 작업의 병렬 수행이 가능하게 했음. 기존의 사람(오퍼레이터)가 하던 작업을 자동화했다고 볼 수 있음.
- 버퍼 : 채널이 사용하는 메모리이자 CPU가 접근하는 메모리 상의 장소. 이 버퍼가 있어 자료를 공유하면서도 서로 간섭없이 각자의 작업을 수행할 수 있게 됨. 연산하는 동안 읽거나 쓰는 것을 가능하게 하여 입출력 대기시간을 없앴음.
- cf. CPU도 버퍼를 접근하고 채널도 버퍼를 접근하는 이상 간섭이 전혀 없을 수는 없고, 충돌 혹은 경쟁이 발생할 수도 있음. 이를 싸이클 스틸링이라는 것으로 해결함.
- 인터럽트 : 채널을 통한 입출력은 CPU의 명령을 받아야 하고, CPU는 입출력 명령이 끝났는지 통보를 받아야 버퍼에 자료를 저장하고 CPU와 입출력장치 간의 자료 공유가 가능해짐. 이를 위해  장치가 작업을 끝내면 CPU에 그 사실을 알리기 시작했는데, 이를 인터럽트라고 함. 이에 따라 CPU에서 수행하는 처리를 ISR(Interupt Service Routine)이라고 함. (이러한 처리는 프로그램이 아니라 하드웨어의 의하여 자동으로 호출되는 것임.) 인터럽트는 입출력 완료 뿐만 아니라 예외동작(파일종료, 테이프 끝, 패리티 오류 등)에서도 발생함.
- cf. 트랩 : 인터럽트와 유사한 소프트웨어적 인터럽트. 언더플로우나 오버플로우 등에서 발생됨.

#### 상주 모니터
- 항상 메모리에 상주하는 프로그램이 필요해짐. 대표적으로는 ISR이 있고, 그 외에도 프로그램을 하나씩 적재해주는 '적재기', 이들에 대한 순차적 수행을 담당하는 'Job Sequencer', 이러한 절차에 대한 프로그래머의 요구를 해석하는 '제어카드 번역기' 등이 있음.
- 이렇게 처음부터 메모리에 상주해야 하는 프로그램을 통칭하여 상주모니터라 불렀음.
- 이것이 운영체제의 원조가 된 것이라고 볼 수 있음.

#### 보호
- 버퍼를 통해 들어온 프로그램이 상주 모니터 영역을 침범하여 손상시킬 수 있음.
- 이를 방지하기 위해 모든 사용자 프로그램은 입출력을 직접하지 않고 상주모니터의 루틴을 호출하여 처리되도록 하였음.
- 미리 테이블에 기록된 허용치를 참조하여 연산 수행 시 리의 접근 범위를 제한했음.

#### 일괄처리 시스템의 장점과 단점
- 이렇게 사람이 작업에 참여하는 초기 일괄처리 시스템에서 채널, 버퍼, 인터럽트, 모니터, 보호 등으로 보완되면서 완성된 일괄처리 시스템은 장점도 있었지만 아쉬운 점이 있었음.
- **장점** : 효율성이 좋아짐 / 하나의 작업이 CPU를 독점하여 하나의 작업의 처리속도는 가장 빠름 -> 사용자와의 대화가 필요하지 않은 CPU-bound 프로그램(수치 계산, 대용량 데이터 처리 등) 수행에 적합
- **단점** : 사용자와의 질의 응답이 필수적일 경우 대답을 받을 때까지 다른 작업을 처리할 수 없기 때문에 사용이 어려움.
- 이에 따라 여러 개의 프로그램을 동시에 수행하는 '다중 프로그래밍'이 등장하게 됨.

## 다중 프로그래밍
---
#### 다중 프로그래밍
- 메모리의 사용자영역에 프로그램이 여러개 탑재되어 있고, CPU가 이를 번갈아가면서 수행함.
- 어떤 프로그램을 수행하다 입출력이 발생하면 해당 입출력이 처리되는 동안 CPU가 다른 프로그램을 수행하는 방식임.
- 여러 프로그램 중 어떤 프로그램을 선택할지는 '스케쥴링'을 통해 해결함. 이는 적절한 정책을 통해 다음 프로그램을 결정해줌.
- 이러한 프로세스는 각 프로그램이 입출력이 발생할 때만 발생됨. 즉, 다른 프로그램으로 작업이 이동되려면 하나의 프로그램이 입출력을 발생해야 함.
- 만약 하나의 프로그램에서 무한 루프가 발생된다면 스케쥴링도 일어나지 않아 나머지 프로그램도 돌아가지 않음. 즉, 다중 프로그래밍 방식에서는 프로그램 간 간섭이 존재함.
- 대부분의 프로그램 실행시간에서 CPU의 사용시간은 극히 일부분이고, 입출력 시간이 대부부을 차지함. 따라서 프로그램 1-N의 실행 시간을 t1, t2, ... tn이라고 한다면, 일괄처리에서는 t1 + t2 + ... + tn의 시간이 소요되던 것이, 다중 프로그래밍에서는 거의 max(t1, t2, ..., tn)에 가까운 시간이 소요됨을 알 수 있음.

#### 버퍼링과 스풀링
- 디중 프로그래밍이 가능해짐에 따라 출려과 동시에 다른 프로그램 수행이 가능해지면서 여러 프로그램에서 출력이 산발적으로 발생할 수 게 됨. 이러한 문제에 대한 해결으로는
- Buffering : 입출력 시 CPU의 속도와 입출력 장치간의 속도 차이를 해소하기 위해 하드 디스크나 메모리 영역에 자료를 잠시 저장해 놓은 것
- Spooling : Buffering과 유사한 개념이지만 버퍼링은 속도의 차이를 해소하기 위한 것이었다면 Spooling은 순차적으로 사용장치(ex. 프린터)를 병렬 수행 프로그램이 사용할 수 있도록 도와주는 방법임. 속도가 빠르고 임의 접근이 가능한 디스크에 출력되는 자료를 임의로 모아놓고 처리함.
- 프로그램1에서 1의 결과를 내고 프로그램2에서 2의 결과를 냄. 그리고 다시 프로그램1에서 3의 결과를 냄. 결과의 처리순서는 1-2-3으로 이루어졌지만 올바른 순서로 프린트하려면 프로그램1에서 수행한 1,3이 프린트되고 프로그램2에서 수행한 2가 프리느되어야 할 것임. 이를 도와주는 것이 Spooling임. 디스크에 자료를 저장했다가 프린터로 그를 보냄으로서 이를 해결함.
- 참고로 SPOOL은 Simultaneous Peripheral Operations On-Line의 약자임.
- cf. 다중 프로그래밍 방식은 여러 프로그램이 메모리에 탐재되어야 했기에 메모리 경영 이슈를 파생시키기도 했음.

#### 시분할 시스템
- 다중 프로그래밍 방식은 입출력이 일어날 때만 스케쥴링이 일어나, 한 프로그램의 입출력 작업이 완료되더라도 해당 프로그램의 작업날 다시 시작할 수 있다는 단점이 있음. 이를 보완하기 위해 등장한 것이 시분할 시스템임.
- 시분한 시스템의 핵심은 '타임슬라이스'임. 입출력 발생시에도 스케쥴링이 일어나지만 타임슬라이스에서 무조건 스케쥴링을 진행하는 것임. 이에 따라 한 프로그램에서 입출력 완료 후 대기 시간이 적어짐. 그에 따라 대화가 빈번한 프로그램도 자연스럽게 수행될 수 있게 됨.
- 이러한 '타임슬라이스'는 타이머 인터럽트를 통해 구현됨. 보통 10ms의 인터벌로 타이머 인터럽트를 설정해 구현됨.
- 1960년 MTS의 CTSS가 시초가 되어 1970년에 하드웨어 상용화로 상용화되고 현재까지 운영체제의 기본 체계로 자리잡음. 
- 이러한 시분할 시스템은 사용자 사이를 재빠르게 전환해줌으로서 사용자로 하여금 컴퓨터를 독점하고 있다고 생각할 수 있게 했음. 실제로 하나의 전산시스템을 여러 개인 모니터에 띄우게 해서 각자의 연구실에서 각자의 작업을 할 수 있도록 했음.
- 다만 한정된 메모리에서 많은 프로그램을 돌려야 했기에 메모리 부족 현상이 일어났음. 이에 따라 '가상 메모리' 기법이 대두되게 되는데 이에 대해서는 추후 자세히 알아볼 것임.
- CPU의 효율성과 사용자의 편의성 모두를 증대시켰다고 할 수 있음.
- 그 외에도 온라인 파일 시스템, 디스크 스케쥴링, CPU 스케쥴링, 프로세서간 통신, 동기화 및 교착상태 처리 등 다양한 이슈가 대두되었음.

#### 실시간 시스템
- 공장생산 라인이나 과학실험 제어, 산업제어, 항공기/미사일 제어, 로봇, 동영상 재생 등의 시스템에서는 프로그램 동작의 실시간성이 중요했음. 즉, 엄격한 마감시간(DEADLINE)이 요구되었음. 이를 만족하는 시스템을 실시간 시스템이라 했음.
- **경성실시간성 (Hard real-time)** : 데드라인 위반시 재앙적 사건이 발생하는 분야(무기제어, 원자력발전소 등). 데드라인을 100% 만족한다는 것을 수학적 혹은 실험적으로 증명해야 함. 가상메모리와 같은 고급기능이나 그 외 모든 부가적 자원관리를 최소화하고 하드웨어와 완전 밀착된 SW를 개발함.
- **연성실시간성 (Soft real-time)** : 데드라인은 존재하지만 재앙적 사건이 발생하지는 않는 분야(동영상 재생 등). 실시간 작업과 일반 작업간의 우선수위 제어정도로 해결함.
- **WCET (Worst Case Execution Time)** : 데드라인 이전에 반드시 수행 시켜야 할 작업을 수행하는데 걸리는 최대 소요시간. 이를 고려하여 데드라인 이전에 해당 작업이 완료될 수 있도록 해야 함.
- 이러한 실시간성을 만족시키기란 매우 어려워 운영체제와는 다른 그룹에서 연구가 지속되어 오고 있음.