# UIKit 공부
## UITableView
---
#### UITablewView란?
iOS의 UITableView는 하나의 열에 세로로 스크롤되는 콘텐츠 행등을 표시함. 스크롤할 수 있는 만큼 UIScrollView를 상속받고 있음. 테이블의 각 행에는 앱 콘텐츠의 일부분이 포함됨. 예를 들어 연락처 앱은 각 연락처의 이름을 별도의 행에 표시함. 또 설정앱으 사용가능한 설정 그룹이 행으로 표시됨. 하나의 긴 행을 표시하도록 테이블을 구성하거나 관련 행을 섹션형태로 그룹화하여 콘텐츠를 더 쉽게 탐색할 수도 있음.

일반적으로 Navigatioin View Controller와 함께 사용하는 것이 일반적임. 이는 테이블의 다양한 계층의 탐색을 용이하도록 도와줌. UITableView는 각 행의 콘텐츠를 표시하는 cell로 구성됨. 표준 cell 구성은 텍스트와 이미지의 단순한 조합이지만 원할 경우 사용자 커스텀 cell을 만들 수도 있음. 또한 header, footer를 생성해 각 그룹에 대한 추가적인 정보를 제공할 수도 있음.

#### UITableView 생성하기
공식문서를 보면 TableView의 생성자는 2개가 존재함을 알 수 있음.

`init?(coder: NSCoder)` 생성자는 unarchiver(스토리보드 혹은 xib 파일)를 기반으로 생성할 때 필요한 생성자이니 `ìnit(frame: CGRect, style: UITableView.Style)` 생성자만 확인하면 됨. frame은 보통 AutoLayout을 통해 잡아줄거니까 .zero로 크기가 없도록 만들어도 상관없음. 

Style은
- plain : 가장 기본적인 스타일
- grouped : 각 섹션에 고유한 행들의 그룹이 있는 스타일
- insetGrouped : 각 섹션의 그룹이 둥근 모서리 형태로 처리된 스타일
이렇게 3가지가 존재함

예를 들면
```swift
var tableView = UITableView(frame: .zero, style: .insetGrouped)
```
이런식으로 적어주면 됨

#### UITableViewDelegate
UITableViewDelegate는 TableView의 여러 기능을 대신 수행하는 역할을 함. UITableViewDelegate가 관리하는 기능은
- Custom Header 및 Footer View를 만들고 관리함.
- Row, Header 및 Footer에 대한 사용자 정의 높이를 지정함.
- 더 나은 스크롤 지원을 위해 높이 추정치를 제공함.
- Row에 Indent를 부여함.
- Row 선택에 응답함.
- Swipe를 포함한 action에 응답함.
- table의 내용을 편집하는데 도움을 줌.

## DequeueReusableCell (withIdentifier: for: ) vs (withIdentifier: )
---
- **func dequeueReusableCell(withIdentifier: for: )** : reuse identifier에 의해 확인된 재사용 가능한 TableVie의 cell을 리턴하고 이를 Table에 추가함.
- **func dequeueReusableCell(withIdentifier: )** : identifier에 의해 확인된 재사용 가능한 TableView의 cell을 배치하고 리턴함.

dequeueReusableell(withIdentifier: for:)을 통해 받아온 cell은 현재 TableView의 size 정보를 바로 가지고 있는 반면 dequeueReusableVell(withIdentifier: )의 통해 받아온 cell은 size 정보를 가지고 있지 않음.

- **func dequeueReusableCell(withIdentifier: for: )** 
  - **IndexPath** : 필요함
  - **리턴값 옵셔널** : 옵셔널 아님
  - **가져온 Cell size** : 해당 tableView에 맞춰짐
- **func dequeueReusableCell(withIdentifier: )**
  - **IndexPath** : 필요없음
  - **리턴값 옵셔널** : 옵셔널임 
  - **가져온 Cell size** : default (320.0, 44.0)

# OS 공부
## 뮤텍스와 세마포어의 차이
---
#### 뮤텍스
- 화장실이 하나 밖에 없는 식당
- 화장실에 가기 위해 카운터에서 열쇠를 가지고 가 그 열쇠를 이용해 화장실을 이용함.
- A가 화장실을 이용 중일 때는 B는 그 열쇠를 카운터에서 기다리게 됨.
- A가 화장실을 다 이용하고 열쇠를 반납하면 B는 그 열쇠를 받아 화장실에 가게 됨.
- **화장실을 이용하는 사람** : 프로세스 또는 스레드
- **화장실** : 공유자원
- Lock을 사용하여 오직 하나의 스레드만 임계 영역에 들어갈 수 있도록 하고 오직 Lock을 건 스레드만이 임계 영역에서 나갈 때 뮤텍스를 unlock 할 수 있음.
#### 세마포어
- 화장실이 여러 칸인 식당
- 화장실에 빈칸이 있다면 화장실에 들어가고, 빈칸의 개수가 0이 되면 1이 될 때까지 기다려야 함.
- **화장실을 이용하는 사람** : 프로세스 또는 스레드
- **화장실** : 공유자원
- 카운트를 가지고 있어 wait를 호출하면 세마포어의 카운트가 줄어들고 signal을 호출하면 카운트가 증가되어 카운트가 0이 되거나 더 작아질 경우 Lock이 실행됨.
- 그렇기 때문에 뮤텍스와는 다르게 Lock을 걸지 않은 스레드도 signal을 통해 Lock을 해제할 수 있음.

## 채널, 버퍼, 인터럽트
---
#### 운영체제의 필요성과 목적
- 메모리나 CPU와 같은 자원은 한정되어 있지만, 사용자는 충분히 무한할 수 있음. -> 이에 따라 이러한 사용자들의 자원 사용을 조율하기 위한 '운영자의 정책'이 필요함.
- 다양한 사용자를 받아들여 최적의 사용율을 보이는 '효율성'과 각각 사용자로서 하여금 불편함이 없을 만큼의 '편의성'을 둘 다 추구해야 함.
- 하지만 이 둘은 결국 상반된 개념임. 한 용자의 편의성을 위해 자원을 한 사용자에게만 주면 결국 자원을 효율적으로 사용하지 못하는 것이고, 모두에게 자원을 똑같이 분배하면 사용자가 많아질수록 사용에 불편을 겪을 수 있기 때문.
- 따라서 이 두 양극의 최적점을 찾는 것이 중요함.
- 정리하면 운영체제는 사용자 관점의 **편의성**, 자원 할당자로서 자원 활용의 **효율성** 마지막으로 다양한 입출력 장치의 운영 및 제어의 **일관성**을 추구해야 함. (운영체제의 목적)

#### 초기 시스템
- 기계어 프로그램을 주로 카드 천공기로 펀치카드에 기록하여 활요했음. 펀치 카드 박스에 프로그램을 담고, 규모가 커지면 마그네틱 테이프를 활용하기도 했음.
- 주로 10진수/8진수의 기계어이고 상대주소가 아닌 절대주소를 사용했음.
- 프로그래머가 콘솔이나 스위치를 이용하여 모든 작업을 수행했음. (테이프나 카드덱의 내용을 적재하고 콘솔을 이용해 프로그램을 수행/디버깅 했음. 라이브러리도 마찬가지로 카드덱 형태였음.)
- 남는 시간이 발생하고 준비 시간도 과도하여 비효율적이었음.
- 한 자원을 독점하니 편의성은 높았지만 효율성은 매우 낮았음. HW가 비싼 시기였기에 효율정을 증대시키는데 많은 노력을 기울였음.

#### 초기 일괄처리 시스템
- 운영자(오퍼레이터, 사람)을 고용하여 사용자들이 요구하는 비슷한 작업을 묶어 배치(batch)로 처리했음. (= 일종의 그룹으로 처리했음.)
- 위성컴퓨터는 배치를 받아 오프라인으로 자기 테이프에 이를 수록했고, 이를 주컴퓨터가 수행하게 한 후, 이 결과를 오프라인으로 위성컴퓨터에서 프린트로 출력했음. 그리고 운영자는 또 른 배치를 다시 위성컴퓨터에 수록, 주컴퓨터가 수행하도록 함. 이를 반복함.
- 쉽게 말해 주컴퓨터는 자기테이프의 작업만 처리하고, 위성커뮤터는 카드뭉치(배치)를 자기테이프로 만들고 결과를 프린트하는 작업만 처리한다는 것임.
- 배치라는 일괄처리 작업을 취급하는 것은 사람이었기 때문에 실수나 불공정함이 존재할 수 있다는 것이 단점이었음.
- 이에 따라 오퍼레이터를 대체하기 위해 채널과 버퍼 그리고 인터럽트라는 개념이 등장하였음.

#### 채널과 버퍼, 인터럽트
- 입추력 장치가 주 컴퓨터의 직접적으로 인터페이스가 되면 오퍼레이터의 작업을 없앨 수 있음.
- 그러면 주컴퓨터의 CPU가 과부화 될 수 있음.
- 채널과 버퍼, 인터럽트의 목적은 입출력장치의 작업과 주컴퓨터의 수행작업이 서로의 간섭없이 각자의 작업을 할 수 있도록 하여 CPU의 과부화를 막는데에 있음.
- 채널 : CPU의 간섭없이 독립적으로 메모리 특정 부분에 직접 자료를 전송하도록 해주는 회로(명령어, 레지스터 및 입출력 제어장치로 구성). CPU와 메모리를 공유하여 CPU로부터 명령을 받음. 이러한 작업을 CPU와는 독립적으로 입출력 처리함으로서 작업의 병렬 수행이 가능하게 했음. 기존의 사람(오퍼레이터)가 하던 작업을 자동화했다고 볼 수 있음.
- 버퍼 : 채널이 사용하는 메모리이자 CPU가 접근하는 메모리 상의 장소. 이 버퍼가 있어 자료를 공유하면서도 서로 간섭없이 각자의 작업을 수행할 수 있게 됨. 연산하는 동안 읽거나 쓰는 것을 가능하게 하여 입출력 대기시간을 없앴음.
- cf. CPU도 버퍼를 접근하고 채널도 버퍼를 접근하는 이상 간섭이 전혀 없을 수는 없고, 충돌 혹은 경쟁이 발생할 수도 있음. 이를 싸이클 스틸링이라는 것으로 해결함.
- 인터럽트 : 채널을 통한 입출력은 CPU의 명령을 받아야 하고, CPU는 입출력 명령이 끝났는지 통보를 받아야 버퍼에 자료를 저장하고 CPU와 입출력장치 간의 자료 공유가 가능해짐. 이를 위해  장치가 작업을 끝내면 CPU에 그 사실을 알리기 시작했는데, 이를 인터럽트라고 함. 이에 따라 CPU에서 수행하는 처리를 ISR(Interupt Service Routine)이라고 함. (이러한 처리는 프로그램이 아니라 하드웨어의 의하여 자동으로 호출되는 것임.) 인터럽트는 입출력 완료 뿐만 아니라 예외동작(파일종료, 테이프 끝, 패리티 오류 등)에서도 발생함.
- cf. 트랩 : 인터럽트와 유사한 소프트웨어적 인터럽트. 언더플로우나 오버플로우 등에서 발생됨.

#### 상주 모니터
- 항상 메모리에 상주하는 프로그램이 필요해짐. 대표적으로는 ISR이 있고, 그 외에도 프로그램을 하나씩 적재해주는 '적재기', 이들에 대한 순차적 수행을 담당하는 'Job Sequencer', 이러한 절차에 대한 프로그래머의 요구를 해석하는 '제어카드 번역기' 등이 있음.
- 이렇게 처음부터 메모리에 상주해야 하는 프로그램을 통칭하여 상주모니터라 불렀음.
- 이것이 운영체제의 원조가 된 것이라고 볼 수 있음.

#### 보호
- 버퍼를 통해 들어온 프로그램이 상주 모니터 영역을 침범하여 손상시킬 수 있음.
- 이를 방지하기 위해 모든 사용자 프로그램은 입출력을 직접하지 않고 상주모니터의 루틴을 호출하여 처리되도록 하였음.
- 미리 테이블에 기록된 허용치를 참조하여 연산 수행 시 리의 접근 범위를 제한했음.

#### 일괄처리 시스템의 장점과 단점
- 이렇게 사람이 작업에 참여하는 초기 일괄처리 시스템에서 채널, 버퍼, 인터럽트, 모니터, 보호 등으로 보완되면서 완성된 일괄처리 시스템은 장점도 있었지만 아쉬운 점이 있었음.
- **장점** : 효율성이 좋아짐 / 하나의 작업이 CPU를 독점하여 하나의 작업의 처리속도는 가장 빠름 -> 사용자와의 대화가 필요하지 않은 CPU-bound 프로그램(수치 계산, 대용량 데이터 처리 등) 수행에 적합
- **단점** : 사용자와의 질의 응답이 필수적일 경우 대답을 받을 때까지 다른 작업을 처리할 수 없기 때문에 사용이 어려움.
- 이에 따라 여러 개의 프로그램을 동시에 수행하는 '다중 프로그래밍'이 등장하게 됨.