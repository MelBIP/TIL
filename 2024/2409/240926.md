# UIKit 공부
## 스토리보드의 장단점
---
#### 장점
- 앱을 실행하지 않고도 전체적인 프로그램 구조와 구성하고 있는 뷰를 미리 확인할 수 있음.
- 뷰를 구성하기가 좀 더 쉽고, 시각화된 화면을 보면서 작업하기 때문에 즉각적인 작업을 처리하기 용이함.
- 앱의 구성이나 흐름을 한눈에 볼 수 있다는 장점이 있음.
- 개발 환경에서 시각적인 도움을 받을 . 수있음.
- 간단한 작업에서 더 빠르게 개발할 수 있음.
- UI code를 적게 사용하여 관리해야 할 files가 적어짐.

#### 단점
- 충돌 문제로 협업이 어렵고 빌드에 더 많은 시간이 소요됨.
- 앱이 커질수록 로딩시간이 길어져 생산성이 떨어질 수 있음.
- 스토리보드를 통해 만든 뷰들은 코드로 만든 뷰보다 재사용성이 떨어짐.
- 코드로만 처리 가능한 부분(border radius 등)이 있기 때문에 따로 스토리보드에서 처리할 수 있도록 설정하는 것도 번거로움.

## Responder Chain
---
#### Responder
- 이벤트를 핸들링하고 이벤트에 반응할 수 있는 객체.
- UIApplication, UIView들을 포함한 많은 주요 객체들 또한 responder.
- 이벤트가 발생하면, UIKit은 이벤트 핸들링을 위해 해당 이벤트의 앱의 responder 객체들에게 보냄.

#### Responder Chain
- 이벤트가 발생한 뷰에서 상위 뷰로 상위 뷰에서 상위 뷰로 상위 뷰에서 상위 뷰컨트롤러로 상위 뷰컨트롤러에서 UIApplication으로 UIApplication에서 UIApplicationDelegate로 연결되는 구조.
- responder 객체들이 이벤트나 액션메세지를 핸들링할 책임을 앱의 다른 객체드르에게 전송할 수 있도록 해줌.
- 특정 정해진 responder가 이벤트를 핸들링하지 않을 경우, 해당 responder는 그 이벤트를 responder chain의 다음 객체에게로 포위당하고 처리가 될 때까지 계속 chain의 상위 객체들로 이동함. 마지막까지 처리되지 않을 경우, 앱이 해당 메시지를 버림.

##  First Responder
----
- 이벤트가 발생했을 때 가장 먼저 이벤트를 받게 되는 Responder.
- UIKit은 이벤트가 발생하면 발생한 이벤트를 First Responder에게 전달하고, First Responder는 받은 이벤트를 터리함. First Responder가 이벤트를 처리하지 않으면 다음 Responder에게 이벤트를 전달하게 됨.
- 앱에서 많은 종류의 이벤트를 처음으로 받는 Responder로 이벤트를 받기 위해서는, responder는 자신이 first responder가 될 수 있음을 나타내야 함.
- first responder가 될 수 있게 하려면, UIReponder의 서브클래스에서 canBecomFirstResponder 프로퍼티를 오버라이드하여 true를 리턴하도록 만들어야 함.
- cf. 이벤트 종류에 따른 First Responder
  - **터치 이벤트** : 터치가 발생한 뷰
  - **프레스 이벤트** : 포커스를 가진 뷰
  - **흔들기 이벤트** : 사용자나 UIKit이 지정한 뷰
  - **원격 이벤트** : 사용자나 UIKit이 지정한 뷰
  - **편집 메뉴 이벤트** : 사용자나 UIKit이 지정한 뷰

# CS 공부
## HTTPS
---
#### HTTPS
기존의 HTTP 방식은 전송 중인 데이터를 가로채면 누구나 데이터를 읽을 수 있었음.
가령 고객이 특정 쇼핑몰에서 신용카드 정보를 작성하여 서버에 전송하면, 해당 내용이 전혀 암호화되지 않은 채로 인터넷을 돌아다니게 되는 것임.

HTTPS는 HTTP의 이런 보안적 문제를 해결한 프로토콜임.
HTTP를 **SSL(Secure Sockets Layer)프로토콜** 위에서 돌아가도록 하여 클라이언트가 서버가 주고받는 텍스트를 암호화함.
즉, HTTP는 HTTP 프로토콜 + SSL 프로토콜인 것임.
HTTPS를 사용하면 통신 내용이 공격자에게 공격받는 것을 방지할 수도 있고, 클라이언트는 접속하려는 서버가 신뢰할 수 있는 서버인지 판단할 수도 있음.

SSL 프로토콜은 SSL 인증서를 사용해 작동함.
SSL 인증서는 클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서임.
클라이언트가 서버에 접속하면 서버는 클라이언트에게 이 인증서 정보를 전달함.
클라이언트는 먼저 이 인증서의 정보가 신뢰할 수 있는지 확인하고 나서야, 작업을 수행함.

SSL 인증서에는 **서비스의 정보(인증서를 발급한 CA, 서비스의 도메인 등)**와 **서버의 공개키**가 포함되어 있음.
이 내용은 앞서 말한 제 3자인 **CA(Certificate Authority, 공개키를 저장해주는 신뢰성이 검증된 민간 기업)**에 의해 암호화됨.
이때 공개키 암호화 기법이 사용되는데, 특이하게 CA의 비공개키로 암호화가 진행됨.
이는 브라우저가 보유한 검증된 CA 공개키에 의해 복호화가 가능함. 
(cf. 브라우저는 신뢰된 CA 기업의 공개키는 모두 보유하고 있음. 따라서 바로 복호화가 가능함.)

**브라우저가 보유한 CA 기업의 공개키로 복호화가 가능하다는 것은 그 데이터가 공개키와 쌍을 이루는 비공개키를 통해 암호화되었음을 인증**하는 것과 같음.
즉, 해당 데이터가 CA 기업으로부터 왔음이 증명된 것임. 그리고 여기서 데이터는 SSL 인증서였으니 이제 클라이언트는 해당 인증서 재부에 존재하는 서버의 공개키가 CA기업의 보안성 검증이 완료된 것임을 확인했음.

이제는 이 사이트를 신뢰할 수 있으므로 해당를 활용해 서버와 소통하며 대칭키인 "세션키"를 생성하고 이를 활용해 통신을 진행함.
이것이 HTTPS의 전반적인 과정임.

**cf. SSL vs TLS**
SSL은 TLS(Transport Layer Security)라는 또 다른 프로토콜의 이전 버전임. 
IETF가 업데이트를 개발하고 NEtscape는 더 이상 참여하지 않게 되면서 이름이 변경되었다고 함.

그래서 사실 **TLS 암호화, TLS Handshake**라고 부르는 것이 좀 더 바람직하지만, SSL의 인지도가 워낙 높기 때문에 그냥 SSL로 부르거나 **TLS/SSL 암호화, TSL/SSL Handshake**와 같은 방식으로 부름.

#### TLS/SSL Handshake
앞서 클라이언트가 서버에 접속하면 서버는 클라이언트에게 SSL 인증서 정보를 전달하고, 해당 인증서가 확인이 된 이후에 내부에 존재하는 공개키를 활용해 "세션키"라는 것을 생성하고 이를 활용해 통신을 시작한다고 했음. 이렇게 SSL 프로토콜을 활용해 통신을 수립하는 과정을 **SSL/TLS Handshake**라고 함.

+) SSL/TLS Handshake의 정확한 단계는 사용되는 키 교환 알고리즘의 유형과 양측에서 지원하는 암호 제품군 유형에 따라 다름. 하지만 대부분 RSA 키 교환 알고리즘을 사용하므로, 그를 기준으로 살펴보겠음.

- **"client hello"** : 클라이언트가 서버로 hello 메세지를 전송하면서 핸드셰이크를 시작함. 이 클라이언트가 지원하는 TLS(SSL) 버전, 지원되는 암호 제품군, 그리고 "client random"이라고 하는 무작위 바이트 문자열이 포함됨.
- **"server hello"** : 클라이언트 hello 메시지에 대한 응답으로 서버가 서버의 SSL 인증서, 서버에서 선택한 암호 제품군, 그리고 서버에서 생성한 또 다른 무작위 바이트 문자열인 "server random"를 포함하는 메시지를 전송함.
- **Verify server certificate** : 클라이언트가 서버의 SSL 인증서를 인증서 발행 기관(CA)을 통해 검증함. 이를 통해 서버가 인증서에 명시된 서버인지, 클라이언트가 상호작용 중인 서버가 실제 해당 도메인의 소유자인지 확인.
- **Client key exchange** : 확인이 완료되면 클라이언트는 "The premaster secret"라고 하는 무작위 바이트 문자열을 공개 키로 암호화하여 전송함. (클라이언트는 서버의 SSL 인증서에서 공개 키를 받음.)
- **Send client certificate** : 만약 서버가 클라이언트의 인증서를 요구한다면 서버의 인증서와 같은 방식으로 암호화를 진행하여 함께 전송함.
- **Verify client certificate** : 서버가 클라이언트로부터 받은 The premaster secret을 개인키를 통해 해독함.
- **Client "finished"** : 클라이언트가 "client random", "server random", "The premaster secret"를 이용해 대칭키로 활용할 "세션 키"를 생성함. 클라이언트가 세션 키로 암호화된 "finished" 메시지를 전송함.
- **Server "finished"** : 서버가 "client random", "server random", "The premaster secret"를 이용해 대칭키로 활용할 "세션 키"를 생성함. 서버가 세션 키로 암호화된 "finished" 메시지를 전송함.
- **Exchange messages** : 핸드셰이크가 완료되고, 세션 키를 이용해 메시지를 주고 받음.

#### HTTPS의 사용
- A라는 서버를 만드는 기업이 HTTPS를 적용하기 위해 공개키와 개인키를 만듦.
- 신뢰할 수 있는 CA 기업에 공개키 관리를 부탁하며 계약을 맺음.
- 계약이 완료된 CA 기업은 A 서버의 공개키, 해당 기업의 이름, 공개키 암호화 방법을 담은 인증서를 만들고 해당 인증서를 CA 기업의 개인키로 암호화해서 A 서버에게 제공함.
- A 서버는 직접적인 공개키가 아닌 암호화된 인증서를 보유하게 됨.
- 클라이언트가 통신 요청을 보내면 앞선 SSL/TLS Handshake 과정을 수행하여 연결을 수립함.
- 클라이언트와 A 서버와 통신을 시작함.

## 흐름제어
---
수신 측이 송신 측보다 데이터 처리 속도가 느릴 경우 데이터를 손실할 위험이 존재함. 흐름 제어는 이런 송신 측과 수신 측의 데이터 처리 속도 차이로 인해 발생하는 문제를 해결하기 위한 기법.

이를 실현하기 위한 방법으로는 Stop and Wait, Sliding Window가 있음.
- **Stop and Wait** : 매번 전송한 패킷에 대해 응답(ACK)을 받으면 다음 패킷을 전송하는 기법임. 이는 패킷을 하나씩 보내고 확인해야 하기 때문에 비효율적임.
- **Sliding Window** : 수신 측에서 설정한 '윈도우'의 크기만큼 송신 츠겡서 패킷을 전송하도록 하여 데이터의 흐름을 동적으로 조절하는 기법임. 최초 윈도우의 크기는 3way-handshaking 과정을 통해 설정되며, 이후 수신측에서 버퍼의 공간에 따라 변경함. ('윈도우'값을 TCP header에 존재하고 관리됨.) 윈도우에 포함된만큼은 수신 측의 응답(ACK)없이도 보낼 수 있지만, 그 이상은 보낼 수 없음. 그 이상의 데이터 패킷을 보내기 위해서는 수신의 응답(ACK)가 확인되어 다시 윈도우의 크기가 갱신되어야 함.