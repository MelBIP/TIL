### 프로퍼티

1. 저장 프로퍼티 - 인스턴스의 변수 또는 상수를 의미

2. 연산 프로퍼티 - 값을 저장하는 게 아닌 특정 연산을 실행하는 결과 값

3. 타입 프로퍼티 - 특정 타입에서만 실행되는 것

### 옵셔널

옵셔널 : 값이 있을 수도 있고, 없을 수도 있음 옵셔널에서만 nil을 사용할 수 있음 → 옵셔널이 아니라면 nil이 아니기 때문에 확인을 안 하고도 쓸 수가 있어 옵셔널이 필요함

해당 변수 또는 상수에는 값이 없을 수 있다.라고 생각하는게 편함 

?, Optional<타입> 모두 사용 가능

var optinalType1: String?
var optinalType2: Optinal<Int>

!을 붙이는게 가장 간단한 방법이지만 가장 위험한 방법 -> 런타임 오류가 일어날 가능성이 가장 높기 때문 강제추출방식은 런타임 오류의 가능성이 높기 때문에 지양하기

옵셔널 바인딩 : 값이 있는지 확인할 때 쓰는 방법 옵셔널 바인딩을 통해 쉼표를 이용해 여러개의 옵셔널을 추출할 수도 있음 

암시적 추출 옵셔널 : nil을 할당하고 싶지만 매번 옵셔널 바인딩으로 추출하는게 귀찮거나 로직상으로 nil 때문에 오류가 안 날 것 같다는 확신이 드는 경우 nil을 할당해줄 수 있는 상수나 변수가 있으면 좋을 것 같다고 생각이 들 때 사용 암시적 추출 옵셔널을 이용하려면 타입 뒤에 !붙임 암시적 추출 옵셔널로 지정된 타입은 일반 값으로도 사용할 수 있지만 여전히 옵셔널이기 때문에 nil도 할당할 수 있음

### struct, class, enum의 차이점

- 구조체는 초기화 코드를 안 적어도 되지만 클래스는 적어줘야 됨

- class
    - ‘인스턴스’라는 용어 사용
    - 단일 상속만
    - (인스턴스/타입) 메서드 or 프로퍼티
    - 참조타입
    - 데이터를 전달할 때 값의 메모리 위치를 전달
    - 주소를 복사하여 이미 존재하는 인스턴스의 위치 가리킴 참조하는 값이 존재하는 위치를 stack 메모리 영역에, 참조되는 값은 heap 메모리 영역에 저장
    - 프레임워크 대부분이 클래스로 구성
- struct
    - 상속 불가
    - (인스턴스/타입) 메서드 or 프로퍼티
    - 값 타입
    - 데이터를 전달할 때 값을 복사하여 전달
    - 값이 복사되어 새로운 인스턴스가 생성되고, 이 인스턴스가 stack 메모리 영역에 저장
    - Swift의 대부분의 뼈대는 모두 구조체로 구성되어 있음
    - 참조가 아닌 복사를 원할 때, 자신을 상속할 필요가 없거나 상속받을 필요가 없을 때 사용
- enum
    - 다른 언어의 열거형과는 다른 존재
    - 유사한 종류의 여러 값을 유의미한 이름으로 한 곳에 모아 정의한 것
    - 열거형 자체가 하나의 데이터 타입
    - 상속 불가
    - (인스턴스/타입) 메서드 or 연산 프로퍼티 지정
    - 기존 프로퍼티는 값을 저장하는 역할을 하지만 연산 프로퍼티는 특정한 연산을 통해 값을 리턴해주는 것을 의미
    - 값 타입
    
### Bounds와 Frame의 차이점

- Bounds : 자기 View가 원점이 됨
- Frame : Super View가 원점이 됨

### Delegate란?

- delegate란 객체 지향 프로그래밍에서 하나의 객체가 모든 일을 처리하는 것이 아니라 처리해야 할 일 중 일부를 다른 객체에게 넘기는 것을 의미
- 객체여서 참조값을 주고 받기때문에 retain이 됨

### View와 Layer의 차이점

- View : 화면에 애플리케이션의 콘텐츠를 나타내기 위해 사용
    - 위치 : UIKit에서 제공
    - 스레드 : 메인 스레드
    - UIResponder : UIResponder의 서브클래스이므로, tap, touch 등의 제스처 인식
    - 기능 : CALayer를 wrapping하고 있는 상태
    - 범용성 : UIKit은 모바일에서만 동작 cf) AppKit은 Mac에서만 동작
- Layer :
    - 위치 : Core Animation에서 제공
    - UIKit과는 다른 별도의 스레드 사용
    - UIRsponder : UIResponder가 없기 때문에 tap, touch 등 인식 X
    - 기능 : 복잡한 애니메이션과 퍼포먼스 측면에서 UIKit보다 우수
    - 범용성 : Mac과 모바일 모두 동작
    
### Struct란?

    - 구조체란, 인스턴스의 값(프로퍼티)을 저장하거나, 기능(메소드)를 제공하고 이를 캡슐화할 수 있도록 스위프트가 제공하는 타입
    - 구조체는 struct 키워드로 정의
    - 구조체 이름은 "새로운 타입을 생성해주는 것"과 마찬가지이므로, 기본 타입 이름처럼 대문자 카멜케이스를 사용하여 지어줌
    - 프로퍼티와 메서드는 소문자 카멜케이스를 사용하여 이름을 지어줌
    
    ```swift
    struct [구조체 이름] { 
        [프로퍼티와 메서드들]
    }
    ```
    
### Extension란?
    
- 정의
    - 존재하는 클래스, 구조체, 열거형, 프로토콜 타입에 새롭게 기능적인 부분을 추가할 수 있고 요구사항을 구현하는 데도 사용할 수 있는 문법
 - 역할
    - 이전의 내부 소스를 접근할 수 없는 원본 타입들에 대해 새로운 기능을 부여할 수 있는 방법
    - 구조체, 클래스, 열거형, 프로포콜의 추가 구현부, 제약사항, 기능 등을 정의     - 특정 타입의 긴으 및 준수하는 프로토콜별 구현부를 분리해서 보다 코드 가독성을 높일 수 있음
- 특징
    - Objective-C의 category와 유사하지만 다른점은 "별도의 이름을 갖지 않음"
    - 타입의 새로운 기능을 추가할 수 있으나, 기존 기능의 오버라이딩은 불허용
    
### 실제 디바이스가 없을 경우 개발 환경에서 할 수 있는 것과 없는 것을 설명하시오.

- 할 수 있는 것 : 앱을 테스트하기 전 빠른 프로토 타이핑 및 개발 가능, iOS 앱을 테스트하고 디버깅하는데 도움이 되는 기능이 있음
- 할 수 없는 것 : 카메라, 마이크, 알림 보내기, 받기

### 앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체를 무엇이라고 하는가?

- UIViewController

### App thinning에 대해서 설명하시오.

- 애플리케이션이 디바이스에 설치될 때, **앱 스토어와 운영체제가 디바이스의 특성에 맞게 설치되도록 하는 설치 최적화 기술**을 의미
- **최소한의 디스크 사용**과 **빠른 다운로드**를 제공
- 구성으로는 **슬라이싱(slicing)**, **비트코드(bitcode)**, **주문형 리소스(on-demand resource)**

### @Main에 대해서 설명하시오.
- @main은 프로그램 실행 시작 시 진입점으로 타입을 지정하기 위한 Swift 언어의 기능
- 사용자는 탑 레벨의 코드를 작성하는 대신 @main단일 유형의 속성을 사용할 수 있고, 라이브러리와 프레임워크는 프로토콜이나 클래스 상속을 통해 맞춤형 진입점 동작을 제공할 수 있음
- @UIApplicationMain 대신 @main을 사용함으로 **타입** 기반의 스위프트 코드에서 이상적인 진입점을 알려주며 m**ain() 함수는 일반 정적 메서드이므로 프로토콜에서 확장 메서드 또는 기본 클래스로 제공 할 수 있다**. -> **자유롭게 Entry Point 지정 가능!**
- 클래스나 구조체에 **@main이 명시된 경우**라면 **static func main()** 메서드가 실제 진입점이 된다! -> **자유롭게 Entry Point 지정 가능!**

### @State란?
- @propertywrapper로, SwiftUI로 하여금 이 프로퍼티가 하고 싶은 행동을 정의하는 타입
- **Property Wrapper는 반복되는 로직들을 프로퍼티 자체에 연결할 수 있다**
- @State라는 인스턴스는 값 자체가 아닌 값을 읽고 쓰는 수단이며, 이 State의 기본 값에 접근하기 위해서 변수의 이름 사용
- 이는 정확하게는 대응되지 않지만, C언어의 포인터를 통해 변수의 값을 참조하는 방식과 유사
- 또한 이 @State 변수는 View 혹은 View에서 호출된 메서드에서만 접근해야함 즉, 사용자가 @State 변수에 직접적으로 접근하지 못하도록 쓰레드에서 변경하는 것이 안전
- @State 변수를 View 내부의 다른 View에 전달하고자 한다면, `$`를 통해 전달 예를 들어, `@State private var isFaceUp: Bool = false`를 `CardView`에 전달하고자 한다면 `CardView(isFaceUp: $isFaceUp)`의 형태로 전달해야함 (그리고 이것을 @Binding으로 받음)
- `State`를 변경 할 때마다 항상 새로운 `View`에서 렌더링 된다는 점 `Strcut` 내부의 값이 전체 `Struct`를 변경할 때마다 전체 구조체가 자동적으로 변경

- 스위프트에서 Extension은 어떻게 사용되나요?
    - 클래스, 구조체, 열거형 타입에 메서드, 프로퍼티, 생성자를 추가적으로 정의해 사용하기 위해 사용
    - 저장 프로퍼티는 정의할 수 없고, 연산 프로퍼티만 정의할 수 있음
    - where을 사용하면 특정한 조건을 가진 타입에서만 extension 적용할 수 있음
- 스위프트의 upcasting과 downcasting의 차이점에 대해 설명하시오
    - 상속 관계에 있는 클래스에서 자식 클래스가 부모 클래스로 타입 캐스팅을 하게 되는 것을 업캐스팅이라 함 as를 사용하여 업캐스팅할 수 있음
    - 다운 캐스팅을 사용할 때도 as를 사용하긴 하지만 실패할 수도 있기 때문에 as?나 as!를 사용함
    - as! 사용할 때 오류가 나면 런타임 에러가 뜨게 됨
    - as? 사용할 때 오류가 나면 nil로 반환됨
- == 연산자와 === 연산자의 차이점
    - == 연산자 : 값 비교할 때 , === 연산자 : 참조 값 비교할 때
- Dispatch Queue의 Serial Queue에 대해 설명하시오.
    - 작업을 한 번에 하나씩 처리하는 큐
    - 먼저 할당한 작업이 끝나야 다음 작업 시작함
- let과 var의 차이점
    - let : 상수 선언할 때
    - var : 변수 선언할 때
- function과 method의 차이점
    - function은 재사용 가능한 코드 블럭을 의미하고, method는 class, struct, enum 안에 포함되어 있는 function을 의미
- mutaing 키워드의 의미
    - 값 타입 프로퍼티들을 인스턴스 메서드에 의해 수정될 수 없음
    - mutaing 키워드를 앞에 붙이면 구조체나 열거형 인스턴스에서 프로퍼티를 수정할 수 있게 됨
    - 구조체의 불변성을 지키기 위해 사용
- 프로토콜과 클래스의 차이점
    - 클래스
        - 인스턴스 메서드의 실체 구현체를 가지고 있음
    - 프로토콜
        - 메서드의 인터페이스만 가지고 있음
        - 구현체를 가지게 하려면 extension을 만들어서 구현체를 작성할 수 있음
- Enum에서 raw value와 associated value에 대해 설명하시오
    - raw value (타입 선언)
        - 원시값으로 열거형의 모든 case들이 동일한 타입을 가지고 하나의 값만 가질 수 있음
    - associated value
        - 튜플을 통해 각 case들이 다른 값을 가지게 할 수도 있음
        - named tuple로 이름을 붙일 수도 있음
        - 여러개의 값을 가지게 하는 것도 가능
- inout은 언제 사용하면 좋을까요?
    - inout 파라미터를 사용하면 값 타입 변수가 저장된 주소의 값을 함수 안과 밖에서 동일하게 사용됨
    - 함수가 입력과 동일한 출력을 제공하고, 함수 내에서 적용된 변동사항이 함수 외에서도 변경이 되어야 할 때 사용할 수 있음
- 연산 프로퍼티와 클로저를 가지는 저장 프로퍼티의 차이점
    - 클로저를 가지는 저장 프로퍼티는 프로퍼티 생성시점에 클로저를 생성하고 사용함
    - var 키워드를 사용하면 다른 클로저를 할당해주는 것도 가능
    - 연산 프로퍼티는 프로퍼티를 참조할 때마다 클로저를 생성하고 실행
- as?와 as!의 차이점
    - 둘 다 다운 캐스팅에서 사용되지만
    - as!
        - 런타임 에러발생
    - as?
        - nil 반환
- 메서드 안에서 언제 self를 사용해야 할까요?
    - 파라미터의 이름이 인스턴스의 프로퍼티의 이름과 같을 경우 인스턴스의 프로퍼티임을 명시하기 위해 self를 사용함
- class와 struct의 공통점과 차이점
    - 공통점
        - 프로토콜 채택할 수 있음
        - 프로퍼티를 정의해 데이터를 저장하고 인스턴스를 만들어 객체의 형태로 만들 수 있음
    - class
        - 참조 타입
        - heap 영역에 인스턴스 저장
        - stack 영역에 인스턴스의 주소값 저장
        - 인스턴스끼리 상속 가능
    - struct
        - 값 타입
        - stack 영역에 인스턴스 저장
        - 상속은 불가능하지만 프로토콜을 통하여 상속의 동작을 구현할 수 있음
- 강한 참조란 무엇이고 왜 필요한 것일까요?
    - 참조 타입 인스턴스를 변수에 할당하는 것을 의미
    - 스위프트의 ARC는 강한 참조에 참조 카운트를 증가시키고, 강한 참조가 해제되면, 참조 카운트를 감소시킴
    - 참조 카운트가 0이 되면 메모리에서 인스턴스를 해제
    - 따라서 강한 참조가 있어야만 참조 타입의 인스턴스를 메모리에 유지시킬 수 있음
- strong, weak, unowed reference는 각각 언제 사용할까요?
    - strong reference
        - 메모리에서 인스턴스가 해제되는 것을 막기 위해
        - 참조의 방향이 단방향으로 이루어지면 항상 안전
        - 참조 카운트를 1씩 증가
    - weak reference
        - 참조 카운트를 증가하지 X
        - 항상 var로 선언되는 옵셔널 타입이 되어야 함
        - 인트턴스가 해제될 수도 있기 때문
        - 순환 참조의 가능성이 있는 상황에서 weak를 통해 방지할 수 있음
    - unowed reference
        - 참조 카운트를 증가시키지 X
        - nil을 가질 수 없음
        - 해당 변수가 참조하는 인스턴스보다 먼저 해제되는 것이 확실한 상황에서만 사용
        - 옵셔널이 아니기 때문에 캡쳐 리스트나 옵셔널 바인딩을 사용하지 않아도 된다는 장점이 있음
- Array, Set, Dictionary의 차이점
    - Array
        - 리스트 컬렉션으로 Random access가 가능하므로 인덱스를 통해 요소에 접근할 수 있음
    - Set
        - 중복되지 않은 데이터를 관리하는 컬렉션
        - Hashable 프로토콜을 채택하는 값을 저장해 순서가 보장되지 않아 집합 연산을 메서드로 제공
    - Dictionary
        - key-value 형태로 데이터를 관리하는 컬렉션
        - 딕셔너리의 Key로 사용될 타입은 Hashable 프로토콜을 채택하고 중복된 키를 허용하지 않으며 순서를 보장하지 않음
- required 키워드에 대해 설명하시오.
    - required가 붙은 클래스의 생성자는 해당 클래스를 상속받는 자식 클래스가 해당 생성자를 반드시 구현하도록 강제함
    - override 키워드의 기능이 포함되어 있으므로 override를 생략하고 구현할 수 있음
- self와 Self의 차이점
    - self는 현재 인스턴스를 가리킴
    - Self는 프로토콜에서 사용되면, 프로토콜을 채택하는 타입의 의미가 되고, 클래스, 구조체, 열거형에서 사용되면 실제 선언에 사용된 타입을 의미
- Array보다 Set을 사용하는게 더 좋을 때는 언제인가요?
    - 순서가 중요하지 않고 데이터를 중복없이 고유하게 관리할 때 Set을 사용하는 것이 더 좋음
    - 순서가 중요하지 않으면서 삽입과 삭제가 빈번하게 일어날 때도 Set 사용하는게 더 좋음
- Trailing Closure란?
    - 함수의 인자로 들어갈 클로저를 함수 호출 외부로 분리하여 코드를 작성하는 방법
    - 파라미터 레이블을 생략할 수 있고, 만약 호출하는 함수의 파라미터가 클로저 뿐이라면 ()도 생략할 수 있음
- @objc는 언제 사용하나요?
    - @objc 는 스위프트의 API를 Objective-C 런타임에 사용할 수 있도록 하기위해 사용
- deinit은 언제 사용하나요?
    - 인스턴스가 메모리에서 해제되기 직전 호출됨 인스턴스를 해제하기 전에 선행되어야 하는 작업이 있다면 deinit에 구현할 수 있음
- DispatchQueue.main.async 와 DispatchQueue.main.sync 의 차이를 설명하시오
    - 두 방법 모두 DispatchQueue에 작업을 등록하고 Main 스레드에서 작업이 수행되도록 함
    - DispatchQueue.main.async는 작업을 등록할 때 async 하게 등록하기 때문에 등록한 작업이 끝나길 기다리지 않고 등록 후 곧바로 다음 코드를 실행
    - DispatchQueue.main.sync는 작업을 등록할 때 sync 하게 등록하기 때문에 등록한 작업이 끝날 때 까지 다음 코드로 진행하지 않음
    - 이때 작업을 등록한 스레드 역시 메인 스레드라면 스레드가 sync에 의해 동작을 멈춘 상태에서 메인스레드에 큐에 등록된 작업이 할당됨
    - 메인 스레드는 큐에 등록했던 작업이 끝나길 기다리고, 동시에 메인 스레드에 할당된 작업은 실행되길 기다리기 때문에 데드락 상태에 빠지게 됨
    - 클래스, 구조체, 열거형 타입에 메서드, 프로퍼티, 생성자를 추가적으로 정의해 사용하기 위해 사용
    - 저장 프로퍼티는 정의할 수 없고, 연산 프로퍼티만 정의할 수 있음
    - where을 사용하면 특정한 조건을 가진 타입에서만 extension 적용할 수 있음


- Defer에 대해 설명하시오
    - defer는 클로저에 정의된 코드가 읽어진 이후에 함수가 끝나기 전 마지막에 실행되도록
    
    ```swift
    func deferTest() {
          print(1)
          defer {
              print("last")
          }
          print(2)
      }
     
      deferTest()
      // 1
      // 2
      // last
    ```
    
    - defer 코드가 실행되지 않으면 함수가 끝나도 클로저는 실행되지 않음
    
    ```swift
    func deferTest() {
          print(1)
          return
          defer {
              print("last")
          }
          print(2)
      }
     
      deferTest()
      // 1
    ```
    
    - 여러개의 defer가 실행되었다면 읽혀진 역순으로 실행
        
        ```swift
        func deferTest() {
              print(1)
              defer {
                  print("last1")
              }
              defer {
                  print("last2")
              }
              defer {
                  print("last3")
              }
              print(2)
          }
         
          deferTest()
          // 1
          // 2
          // last3
          // last2
          // last1
        ```
        
    - 중첩된 defer는 바깥쪽 defer 부터 실행
    
    func deferTest() {
      print(1)
      defer {
          print("last1")
          defer {
              print("last2")
              defer {
                  print("last3")
              }
          }
      }
      print(2)
  }
 
  deferTest()
  // 1
  // 2
  // last1
  // last2
  // last3
