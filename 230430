### 프로퍼티

1. 저장 프로퍼티 - 인스턴스의 변수 또는 상수를 의미

2. 연산 프로퍼티 - 값을 저장하는 게 아닌 특정 연산을 실행하는 결과 값

3. 타입 프로퍼티 - 특정 타입에서만 실행되는 것

### 옵셔널

옵셔널 : 값이 있을 수도 있고, 없을 수도 있음 옵셔널에서만 nil을 사용할 수 있음 → 옵셔널이 아니라면 nil이 아니기 때문에 확인을 안 하고도 쓸 수가 있어 옵셔널이 필요함

해당 변수 또는 상수에는 값이 없을 수 있다.라고 생각하는게 편함 

?, Optional<타입> 모두 사용 가능

var optinalType1: String?
var optinalType2: Optinal<Int>

!을 붙이는게 가장 간단한 방법이지만 가장 위험한 방법 -> 런타임 오류가 일어날 가능성이 가장 높기 때문 강제추출방식은 런타임 오류의 가능성이 높기 때문에 지양하기

옵셔널 바인딩 : 값이 있는지 확인할 때 쓰는 방법 옵셔널 바인딩을 통해 쉼표를 이용해 여러개의 옵셔널을 추출할 수도 있음 

암시적 추출 옵셔널 : nil을 할당하고 싶지만 매번 옵셔널 바인딩으로 추출하는게 귀찮거나 로직상으로 nil 때문에 오류가 안 날 것 같다는 확신이 드는 경우 nil을 할당해줄 수 있는 상수나 변수가 있으면 좋을 것 같다고 생각이 들 때 사용 암시적 추출 옵셔널을 이용하려면 타입 뒤에 !붙임 암시적 추출 옵셔널로 지정된 타입은 일반 값으로도 사용할 수 있지만 여전히 옵셔널이기 때문에 nil도 할당할 수 있음

### struct, class, enum의 차이점

- 구조체는 초기화 코드를 안 적어도 되지만 클래스는 적어줘야 됨

- class
    - ‘인스턴스’라는 용어 사용
    - 단일 상속만
    - (인스턴스/타입) 메서드 or 프로퍼티
    - 참조타입
    - 데이터를 전달할 때 값의 메모리 위치를 전달
    - 주소를 복사하여 이미 존재하는 인스턴스의 위치 가리킴 참조하는 값이 존재하는 위치를 stack 메모리 영역에, 참조되는 값은 heap 메모리 영역에 저장
    - 프레임워크 대부분이 클래스로 구성
- struct
    - 상속 불가
    - (인스턴스/타입) 메서드 or 프로퍼티
    - 값 타입
    - 데이터를 전달할 때 값을 복사하여 전달
    - 값이 복사되어 새로운 인스턴스가 생성되고, 이 인스턴스가 stack 메모리 영역에 저장
    - Swift의 대부분의 뼈대는 모두 구조체로 구성되어 있음
    - 참조가 아닌 복사를 원할 때, 자신을 상속할 필요가 없거나 상속받을 필요가 없을 때 사용
- enum
    - 다른 언어의 열거형과는 다른 존재
    - 유사한 종류의 여러 값을 유의미한 이름으로 한 곳에 모아 정의한 것
    - 열거형 자체가 하나의 데이터 타입
    - 상속 불가
    - (인스턴스/타입) 메서드 or 연산 프로퍼티 지정
    - 기존 프로퍼티는 값을 저장하는 역할을 하지만 연산 프로퍼티는 특정한 연산을 통해 값을 리턴해주는 것을 의미
    - 값 타입
    
### Bounds와 Frame의 차이점

- Bounds : 자기 View가 원점이 됨
- Frame : Super View가 원점이 됨

### Delegate란?

- delegate란 객체 지향 프로그래밍에서 하나의 객체가 모든 일을 처리하는 것이 아니라 처리해야 할 일 중 일부를 다른 객체에게 넘기는 것을 의미
- 객체여서 참조값을 주고 받기때문에 retain이 됨

### View와 Layer의 차이점

- View : 화면에 애플리케이션의 콘텐츠를 나타내기 위해 사용
    - 위치 : UIKit에서 제공
    - 스레드 : 메인 스레드
    - UIResponder : UIResponder의 서브클래스이므로, tap, touch 등의 제스처 인식
    - 기능 : CALayer를 wrapping하고 있는 상태
    - 범용성 : UIKit은 모바일에서만 동작 cf) AppKit은 Mac에서만 동작
- Layer :
    - 위치 : Core Animation에서 제공
    - UIKit과는 다른 별도의 스레드 사용
    - UIRsponder : UIResponder가 없기 때문에 tap, touch 등 인식 X
    - 기능 : 복잡한 애니메이션과 퍼포먼스 측면에서 UIKit보다 우수
    - 범용성 : Mac과 모바일 모두 동작
    
### Struct란?

    - 구조체란, 인스턴스의 값(프로퍼티)을 저장하거나, 기능(메소드)를 제공하고 이를 캡슐화할 수 있도록 스위프트가 제공하는 타입
    - 구조체는 struct 키워드로 정의
    - 구조체 이름은 "새로운 타입을 생성해주는 것"과 마찬가지이므로, 기본 타입 이름처럼 대문자 카멜케이스를 사용하여 지어줌
    - 프로퍼티와 메서드는 소문자 카멜케이스를 사용하여 이름을 지어줌
    
    ```swift
    struct [구조체 이름] { 
        [프로퍼티와 메서드들]
    }
    ```
    
### Extension란?
    
- 정의
    - 존재하는 클래스, 구조체, 열거형, 프로토콜 타입에 새롭게 기능적인 부분을 추가할 수 있고 요구사항을 구현하는 데도 사용할 수 있는 문법
 - 역할
    - 이전의 내부 소스를 접근할 수 없는 원본 타입들에 대해 새로운 기능을 부여할 수 있는 방법
    - 구조체, 클래스, 열거형, 프로포콜의 추가 구현부, 제약사항, 기능 등을 정의     - 특정 타입의 긴으 및 준수하는 프로토콜별 구현부를 분리해서 보다 코드 가독성을 높일 수 있음
- 특징
    - Objective-C의 category와 유사하지만 다른점은 "별도의 이름을 갖지 않음"
    - 타입의 새로운 기능을 추가할 수 있으나, 기존 기능의 오버라이딩은 불허용
    
### 실제 디바이스가 없을 경우 개발 환경에서 할 수 있는 것과 없는 것을 설명하시오.

- 할 수 있는 것 : 앱을 테스트하기 전 빠른 프로토 타이핑 및 개발 가능, iOS 앱을 테스트하고 디버깅하는데 도움이 되는 기능이 있음
- 할 수 없는 것 : 카메라, 마이크, 알림 보내기, 받기

### 앱 화면의 콘텐츠를 표시하는 로직과 관리를 담당하는 객체를 무엇이라고 하는가?

- UIViewController

### App thinning에 대해서 설명하시오.

- 애플리케이션이 디바이스에 설치될 때, **앱 스토어와 운영체제가 디바이스의 특성에 맞게 설치되도록 하는 설치 최적화 기술**을 의미
- **최소한의 디스크 사용**과 **빠른 다운로드**를 제공
- 구성으로는 **슬라이싱(slicing)**, **비트코드(bitcode)**, **주문형 리소스(on-demand resource)**

### @Main에 대해서 설명하시오.
- @main은 프로그램 실행 시작 시 진입점으로 타입을 지정하기 위한 Swift 언어의 기능
- 사용자는 탑 레벨의 코드를 작성하는 대신 @main단일 유형의 속성을 사용할 수 있고, 라이브러리와 프레임워크는 프로토콜이나 클래스 상속을 통해 맞춤형 진입점 동작을 제공할 수 있음
- @UIApplicationMain 대신 @main을 사용함으로 **타입** 기반의 스위프트 코드에서 이상적인 진입점을 알려주며 m**ain() 함수는 일반 정적 메서드이므로 프로토콜에서 확장 메서드 또는 기본 클래스로 제공 할 수 있다**. -> **자유롭게 Entry Point 지정 가능!**
- 클래스나 구조체에 **@main이 명시된 경우**라면 **static func main()** 메서드가 실제 진입점이 된다! -> **자유롭게 Entry Point 지정 가능!**

### @State란?
- @propertywrapper로, SwiftUI로 하여금 이 프로퍼티가 하고 싶은 행동을 정의하는 타입
- **Property Wrapper는 반복되는 로직들을 프로퍼티 자체에 연결할 수 있다**
- @State라는 인스턴스는 값 자체가 아닌 값을 읽고 쓰는 수단이며, 이 State의 기본 값에 접근하기 위해서 변수의 이름 사용
- 이는 정확하게는 대응되지 않지만, C언어의 포인터를 통해 변수의 값을 참조하는 방식과 유사
- 또한 이 @State 변수는 View 혹은 View에서 호출된 메서드에서만 접근해야함 즉, 사용자가 @State 변수에 직접적으로 접근하지 못하도록 쓰레드에서 변경하는 것이 안전
- @State 변수를 View 내부의 다른 View에 전달하고자 한다면, `$`를 통해 전달 예를 들어, `@State private var isFaceUp: Bool = false`를 `CardView`에 전달하고자 한다면 `CardView(isFaceUp: $isFaceUp)`의 형태로 전달해야함 (그리고 이것을 @Binding으로 받음)
- `State`를 변경 할 때마다 항상 새로운 `View`에서 렌더링 된다는 점 `Strcut` 내부의 값이 전체 `Struct`를 변경할 때마다 전체 구조체가 자동적으로 변경
